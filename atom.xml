<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Norld&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://norld.com/"/>
  <updated>2020-03-22T04:18:02.000Z</updated>
  <id>http://norld.com/</id>
  
  <author>
    <name>Norld</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>对 FKDownloader 的完全重构</title>
    <link href="http://norld.com/2020/02/03/%E5%AF%B9%20FKDownloader%20%E7%9A%84%E5%AE%8C%E5%85%A8%E9%87%8D%E6%9E%84/"/>
    <id>http://norld.com/2020/02/03/对 FKDownloader 的完全重构/</id>
    <published>2020-02-03T05:46:30.000Z</published>
    <updated>2020-03-22T04:18:02.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>当初编写 0.x 版本时, 尚未考虑过多逻辑, 整体架构就是简单的封装系统逻辑, 导致在后期频频出问题, 而打补丁只会出更多的问题, 毕竟底子并没有打好, 所以就起了重构的心思.</p><a id="more"></a><h3 id="灵感"><a href="#灵感" class="headerlink" title="灵感"></a>灵感</h3><p>刚一开始想参考一下 <code>aria2</code> 这个大佬级下载软件, 但奈何这软件涉及的下载方式过于复杂, 而且 iOS 的封闭式导致大部分逻辑不能使用, 强行借鉴是没有好下场的, 只好另作打算.</p><p>之前因为需要为自己的 App 编写后台, 就接触到了 Python, 当时为了将一些资源整合到自己的数据库中, 就发现了 <code>Scrapy</code> 这个大名鼎鼎的爬虫框架, 而这个框架的逻辑恰好符合我的想法.</p><p>根据 iOS 下载系统的特性, 下载框架会按下图的流程进行制作:<br><img src="https://pic.downk.cc/item/5e4d253e48b86553eea38f27.png" alt=""></p><p>至于为什么要这么做, 主要还是得看制作一个后台下载框架都有什么难点.</p><h3 id="后台下载框架主要难点与关键点"><a href="#后台下载框架主要难点与关键点" class="headerlink" title="后台下载框架主要难点与关键点"></a>后台下载框架主要难点与关键点</h3><ol><li><p>下载任务和下载流程全部归系统管理<br>首先, iOS 后台下载的主要流程基本为: 创建 <code>NSURL</code> -&gt; 创建 <code>NSURLRequest</code> -&gt; 使用 <code>Session</code> 和 <code>NSURLRequest</code> 生成 <code>NSURLSessionDownloadTask</code>, 之后的下载信息, 如下载进度, 下载失败和下载成功等事件可以通过设置代理后获得.</p><p>然后, 如何在重启 App 后获得下载任务? 可以通过 <code>-[NSURLSession getTasksWithCompletionHandler:]</code> 获取.</p><p>但这个方法真的能获取所有请求吗? 官方文档有解释:</p><blockquote><p>The arrays passed to the completion handler contain any tasks that you have created within the session, not including any tasks that have been invalidated after completing, failing, or being cancelled.</p></blockquote><p>显而易见, 对于已经失效的任务是获取不到的, 所以拥有一套任务记录模块是必须的.</p><p>还有一种情况, 链接重定向, 这会导致拿到 <code>NSURLSessionDownloadTask</code> 后, 不知道对应那个下载链接, 这种情况的解决方案有几种, 可以监听 <code>NSURLSessionDownloadTask</code> 的 <code>currentRequest</code> 属性来记录最终下载链接, 也可以使用 <code>taskDescription</code> 属性放置一个标记, 当然, 也许还有其他方法.</p></li><li><p>获取任务进度的自由度<br>对于 <code>NSURLSessionDownloadTask</code>, 有 <code>countOfBytesReceived</code> 和 <code>countOfBytesExpectedToReceive</code> 这两个属性可以获取已下载字节长度和预计全部数据长度, 还有一些新的属性也可以获取这些信息.</p><p>显然, 对于单一任务来说, 这已经足够了, 但对于多个任务, 并且可以任意分组的情况来说, 那就需要一个统一记录进度的模块了.</p></li><li><p>奇奇怪怪得系统 BUG<br>这些个 BUG 虽然都有应对方法, 但部分应对方法会影响一些逻辑.</p><p>比如在 <code>iOS 12/12.1, iPhone 8</code> 以下机型会出现 <code>NSURLSessionDownloadTask</code> 的 <code>countOfBytesReceived</code> 和 <code>countOfBytesExpectedToReceive</code> 属性在进入后台, 再回到前台后, 不再变更数值的问题, 需要来一个暂停/恢复的改变才会继续工作, 这就需要框架有一个监听前/后台切换的逻辑, 去处理这个问题.</p><p>还有那个恢复数据有问题导致恢复下载失败的问题, 需要在每次恢复下载时做一次修复处理, 对于一些需要将恢复数据保存到本地的逻辑来说, 就需要特殊逻辑来使这些逻辑共存.</p><p>对于 Apple 来说, 后台下载这些逻辑明显是不想让开发者过多干涉, 所以在出现一些问题时, 开发者很被动, 只能找着法子各种规避了.</p></li><li><p>任务列表<br>每个带有下载功能的 App 基本上都会有下载列表, 但在下载框架里, 最好不要现实下载列表功能, 这毕竟属于 App 的业务逻辑.</p><p>而且因为业务影响, UI 影响, 会导致数据结构千奇百怪, 第三方框架没必要兼容, 也兼容不了.</p><p>所以任务信息相关的模块最好保持懒加载模式, 需要的时候直接拿来用, UI 相关的数据只保留最基本的数据, 其他信息可以由 App 端实现.</p></li></ol><h3 id="框架模块"><a href="#框架模块" class="headerlink" title="框架模块"></a>框架模块</h3><p>接下来就是根据架构流程图创建各种模块了, 在 <code>FKDownloader</code> 中有两种类型的模块, 一种公开类型, 一种私有类型.</p><p>公开模块为面向用户的模块, 包含 <code>FKBuilder</code>(构建任务), <code>FKMessager</code>(获取信息), <code>FKConfigure</code>(下载配置), <code>FKControl</code>(控制任务), <code>FKMiddleware</code>(中间件) 五个模块.</p><p>私有模块为框架内部使用模块, 包含主要模块: <code>FKEngine</code>, <code>FKCache</code>, <code>FKObserver</code>, <code>FKScheduler</code>, <code>FKSessionDelegater</code>.</p><p>还有辅助模块: <code>FKSingleNumber</code>, <code>FKFileManager</code>, <code>FKLogger</code>, <code>FKCoder</code>, FKMIMEType.</p><p>还有一些数据模型: <code>FKObserverModel</code>, <code>FKCacheRequestModel</code>, <code>FKResponse</code>.</p><p>它们将按照流程图来处理下载任务, 大体上来讲, <code>FKBuilder</code> 是输入, <code>FKMessager</code> 是输出, <code>FKEngine</code> 是处理, <code>FKControl</code> 是控制, <code>FKCache</code> 是储存.</p><h3 id="框架模块详细讲解"><a href="#框架模块详细讲解" class="headerlink" title="框架模块详细讲解"></a>框架模块详细讲解</h3><p>首先, 是公开模块.</p><h5 id="FKBuilder"><a href="#FKBuilder" class="headerlink" title="FKBuilder"></a>FKBuilder</h5><p>该模块主要对应 <code>创建NSURLRequest</code> 阶段, 独立出来是为了更好的控制构建 <code>NSURLReqest</code> 的过程.</p><p>鉴于 NSURLReqest 的属性和方法会随着系统更新变得越来越多, 越来越复杂, 且自定义不会对生成 <code>NSURLSessionDownloadTask</code> 流程产生影响, 所以 <code>FKBuilder</code> 直接继承于 <code>NSMutableURLRequest</code>, 用户可以像操作 <code>NSMutableURLRequest</code> 一样操作 <code>FKBuilder</code>. 对于用户传入的 URL 是否合法, 也可在初始化时进行校验.</p><p><code>FKBuilder</code> 需要显式执行预处理, 这样才能将任务加入队列中.</p><h5 id="FKMessager"><a href="#FKMessager" class="headerlink" title="FKMessager"></a>FKMessager</h5><p>该模块对应请求信息收集逻辑, 比如进度、状态、错误等.</p><p>基本上所有有关下载的业务逻辑, 添加下载的界面和查看下载进度的是分开的, 所以, FKDownloader 就干脆将任务信息收集相关逻辑全部独立出来, 同时也可以更好的对应列表样式的信息获取.</p><h5 id="FKConfigure"><a href="#FKConfigure" class="headerlink" title="FKConfigure"></a>FKConfigure</h5><p>一个下载框架如果不能自定义配置, 那就没有灵魂.</p><p>查看 <code>NSURLSessionConfiguration</code> 的官方文档就会发现系统提供的参数巨多, 而且还包含了新版本特性, 这就导致对外开放什么属性/方法成了难题, 多了不可控, 少了又没有高度自定义那味, 所以 <code>FKConfigure</code> 直接提供了一个 <code>NSURLSessionConfiguration</code> 模版, 化为属性, 只把其中的能否使用蜂窝 <code>allowsCellularAccess</code> 默认设置为允许, 其他通通由用户自定义.</p><p>至于 <code>NSMutableURLRequest</code> 和 <code>NSURLSessionConfiguration</code> 的部分属性冲突, 这部分官方已经在注释里讲的很明白了, 用户可自行斟酌.</p><h5 id="FKControl"><a href="#FKControl" class="headerlink" title="FKControl"></a>FKControl</h5><p>这就是个控制任务的, 激活、暂停、继续、停止、删除, 没什么好说的, 独立出来只是为了面向用户, 不用跟其他私有模块产生冲突, 而且多出一层, 可操作性也会多一层.</p><h5 id="FKMiddleware"><a href="#FKMiddleware" class="headerlink" title="FKMiddleware"></a>FKMiddleware</h5><p>中间件模块, 我也就在爬虫框架和后端框架中见过, <code>FKDownloader</code> 中有这种模块主要是为了有一种可以统一处理的方式.</p><p>目前该模块只在生成 <code>NSURLSessionDownloadTask</code> 前, 下载成功/失败后会有介入, 前者是为了诸如请求统一加签、绕过浏览器限制等操作, 后者可以当成 <code>NSURLSession</code> 代理中下载成功/失败的回调即可.</p><p>更多的操作可根据业务自行调整.</p><hr><hr><p>再来是私有模块.</p><h5 id="FKEngine"><a href="#FKEngine" class="headerlink" title="FKEngine"></a>FKEngine</h5><p>该模块基本就是框架运转的核心.</p><p>在一般下载逻辑中, 会为每个任务创建一个计时器, 实现进度信息分发逻辑, 但这一块儿其实用不了那么多, 还会因为管理不过来出现问题(0.x版本就有这类问题), 所以在 <code>FKEngine</code> 中只有两个个计时器, 只为了更简洁的操作, 毕竟在实际业务中, 这些进度条各走各还是一起走都无所谓,</p><p>计时器主要完成以下任务:</p><ol><li>检查任务队列, 进行下一个任务</li></ol><p>首先, <code>FKBuilder</code> 的预处理会将生成的任务信息模型(<code>FKCacheRequestModel</code>) 存入 <code>FKCache</code> 的缓存队列中, 但不开始任务, 也不创建 <code>NSURLSessionDownloadTask</code>, 这是前提, 与计时器无关.</p><p>然后, 计时器被触发后就会检查队列中正在执行的任务是否超过设置, 超过了就什么也不做, 没超过就开始用任务信息创建 <code>NSURLSessionDownloadTask</code>, 进行下载, 期间走过中间件流程, 本地信息缓存流程, 监听信息流程等等流程.</p><p>执行任务计时器的间隔为 1s, 不可自定义.</p><ol start="2"><li>分发任务信息</li></ol><p>在使用 <code>FKMessager</code> 时, 回调会被缓存, 计时器被触发后将会轮询执行这些回调</p><p>以上任务都会在计时器触发后执行. 默认情况下, 这个计时器是停止的, 需要用 <code>FKConfigure</code> 来激活, 这是为了保证在 <code>NSURLSession</code> 被创建后再执行任务.</p><p>计时器重复时间默认设定为 1s, 这个时间刚刚好, 少了太频繁, 多了感觉慢.<br>也支持用户自定义速率, 目前 1 倍速率为 0.2 秒, 倍率在 1 ~ 10 倍区间可自定义.</p><p>除此之外, 应用启动后还会去查询后台已经存在的下载任务, 将这些任务添加到缓存中, 让它们和其他任务一致.</p><p>基本上其他模块只是制造信息, 输出信息和保存信息, 而 <code>FKEngine</code> 则是让整个框架活过来.</p><h5 id="FKCache"><a href="#FKCache" class="headerlink" title="FKCache"></a>FKCache</h5><p>主要负责信息缓存, 任务的信息, <code>NSURLSessionDownloadTask</code> 等等.</p><p>独立的缓存模块是必须的, 要缓存的信息有很多, 集中起来更容易管理.</p><p>在 <code>FKDownloader</code> 中, 对任务有一个主要理念: <code>任务即文件, 文件即任务</code>, 每一个任务都有一个属于自己的唯一标识, 标识与用户输入的链接息息相关, 也和本地缓存有着千丝万缕的联系.</p><p>在 <code>FKDownloader</code> 中的文件就是 <code>FKCacheRequestModel</code> 对应的归档文件, 这个模型提供的信息有:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, strong) NSString *requestID; // 请求标识, SHA256(URL)</span><br><span class="line">@property (nonatomic, strong) NSString *requestSingleID; // 唯一请求标识, SingleNumber_SHA256(URL)</span><br><span class="line">@property (nonatomic, strong) NSString *idx; // 唯一顺序编码</span><br><span class="line">@property (nonatomic, strong) NSString *url; // 原始请求链接</span><br><span class="line">@property (nonatomic, strong) NSMutableURLRequest *request; // 请求</span><br><span class="line">@property (nonatomic, assign) FKState state; // 请求状态</span><br><span class="line">@property (nonatomic, assign) int64_t receivedLength; // 接收的数据长度</span><br><span class="line">@property (nonatomic, assign) int64_t dataLength; // 数据长度</span><br><span class="line">@property (nonatomic, strong) NSString *extension; // 文件后缀, `.*`</span><br><span class="line">@property (nonatomic, strong, nullable) NSData *resumeData; // 恢复数据</span><br><span class="line">@property (nonatomic, strong, nullable) NSError *error; // 错误</span><br></pre></td></tr></table></figure><p>基本上可以构成/恢复任务的信息都在里面, 每一个任务都有自己的文件夹保存这些信息, 分而治之有利于管理, 0.x版本中都是所有任务都在一个文件中, 不管从性能上看, 还是管理上看, 都有很大的问题.</p><h5 id="FKObserver"><a href="#FKObserver" class="headerlink" title="FKObserver"></a>FKObserver</h5><p>众多任务需要监听的流程太过繁杂也太过分散, 系统 BUG 还导致这些监听还需要重新添加, 这就更分散了. 而获取进度信息在业务上来讲并不频繁使用, 这些监听到的信息全放在任务信息模型里也不合适, 那么, 直接独立出来成模块岂不美哉.</p><p><code>FKObserver</code> 以专门监听 <code>NSURLSessionDownloadTask</code> 而生, 所有任务的进度信息都在这里.</p><p><code>FKObserver</code> 使用 <code>FKObserverModel</code> 保存进度信息, 基本信息如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@interface FKObserverModel : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong) NSString *requestID; // SHA256(Request.URL)</span><br><span class="line">@property (nonatomic, assign) int64_t countOfBytesReceived;</span><br><span class="line">@property (nonatomic, assign) int64_t countOfBytesPreviousReceived;</span><br><span class="line">@property (nonatomic, assign) int64_t countOfBytesExpectedToReceive;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>简约而不简单, 并且和 <code>FKMessager</code> 配合完美, 一个对外, 一个对内.</p><h5 id="FKScheduler"><a href="#FKScheduler" class="headerlink" title="FKScheduler"></a>FKScheduler</h5><p><code>FKBuilder</code> 和 <code>FKEngine</code> 之间的模块, <code>FKControl</code> 的实现, 主要任务如下:</p><ol><li>对 <code>FKBuilder</code> 的预处理逻辑进行了更细节的处理. 如创建任务信息文件, 添加内存/本地缓存, 忽略已存在任务等.</li><li>实现 <code>FKControl</code> 的操作, 激活、暂停、继续、取消、删除.</li></ol><h5 id="FKSessionDelegater"><a href="#FKSessionDelegater" class="headerlink" title="FKSessionDelegater"></a>FKSessionDelegater</h5><p>实现 <code>NSURLSession</code> 的代理, 没啥好说, 单独摘出来是因为代理方法还是很多很复杂的, 为了之后更好的扩展, 这样更好一些.</p><hr><hr><p>还有一些辅助用模块</p><h5 id="FKSingleNumber"><a href="#FKSingleNumber" class="headerlink" title="FKSingleNumber"></a>FKSingleNumber</h5><p>在执行下一个任务时, 哪个才是下一个? 按添加顺序可不一定准, 所以 <code>FKDownloader</code> 直接使用 <code>stdatomic.h</code> 中的 <code>atomic_ullong</code> 来创建一个不受线程影响的原子数, 再让它被获取时自增.</p><p><code>FKCacheRequestModel</code> 的 <code>requestSingleID</code> 就是原子数和下载链接的哈希值拼接出来的.</p><p>当然, 从业务上来讲, 任务的执行顺序是否按照列表所示顺序依次进行好像并不怎么重要.</p><h5 id="FKFileManager"><a href="#FKFileManager" class="headerlink" title="FKFileManager"></a>FKFileManager</h5><p>文件管理的封装, 主要负责创建/删除任务对应的文件/文件夹.</p><h5 id="FKLogger"><a href="#FKLogger" class="headerlink" title="FKLogger"></a>FKLogger</h5><p>辅助信息日志, 这倒是没啥好说的, 只是为了更方便调试, 信息只会在 DEBUG 环境下执行.</p><h5 id="FKCoder"><a href="#FKCoder" class="headerlink" title="FKCoder"></a>FKCoder</h5><p>URL 编解码.</p><p>先说编码, 有一个问题便是用户传入的下载链接是否已经编码过, 这个可以循环解码至和上一个结果一致时停下, 这个问题不算太大. 但 URL 可能有带有 <code>emoji</code>, <code>fragment</code> 的情况, <code>emoji</code> 可以用系统的 <code>URLQueryAllowedCharacterSet</code> 直接处理, 但 <code>fragment</code> 就会编码错误, 这时就需要分段处理.</p><p>再说解码, 这个就简单了, 直接 <code>stringByRemovingPercentEncoding</code> 走起.</p><h5 id="FKMIMEType"><a href="#FKMIMEType" class="headerlink" title="FKMIMEType."></a>FKMIMEType.</h5><p>既然是文件下载, 那基本上都有后缀吧, 直接从 URL 里获取是不现实的, 毕竟有的链接是加签的, 后缀是不存在的, 所以要用 <code>Response</code> 中的 <code>Content-Type</code> 也就是 <code>MIMEType</code> 来转为后缀名.</p><p>系统可以讲 <code>MIMEType</code> 转为后缀, 但并不全面, 所以需要将其他常用的加入转换列表中, 如果实在没有对应后缀名, 就用 <code>unknown</code> 为后缀名.</p><h3 id="关于后台下载的-Tips"><a href="#关于后台下载的-Tips" class="headerlink" title="关于后台下载的 Tips"></a>关于后台下载的 Tips</h3><p>后台下载功能中也存在一些需要知道的东西.</p><h6 id="后台任务由系统启动后的各种限制"><a href="#后台任务由系统启动后的各种限制" class="headerlink" title="后台任务由系统启动后的各种限制"></a>后台任务由系统启动后的各种限制</h6><p>先说结论, 目前没有什么好的方法去绕过. 系统的限制基本上有以下几种:</p><ol><li>限制下载速度</li><li>限制何时启动下一个任务的时间</li><li>限制任务启动数量</li><li>….</li></ol><p>总的来说, iOS 为了达到完美的运行并且不会影响系统的稳定性, 后台下载的内核做了非常多的限制, 而且为什么有这些限制, 又是怎样做到的, 官方并没有明说, 只能从<a href="https://forums.developer.apple.com/thread/14854" target="_blank" rel="noopener">这里</a>看出一个重点信息, NSURLSession Background Download 是系统包揽的, 开发者最好不要深入研究.</p><h6 id="测试后台下载流程"><a href="#测试后台下载流程" class="headerlink" title="测试后台下载流程"></a>测试后台下载流程</h6><p>从<a href="https://forums.developer.apple.com/thread/14855" target="_blank" rel="noopener">这里</a>可以看出, 测试时一定要严格遵守以下几点:</p><ol><li>Test on a real device, not the simulator. 在真机上测试, 而不是模拟器.</li><li>Run your app from the Home screen rather than running it from Xcode. 从主屏幕上运行, 而不是 Xcode 直接运行.</li><li>Do not use force quit to test the ‘relaunch in the background case’. 不要从任务管理中强制退出 App 来模拟后台下载流程中的强制中断 App 逻辑, 而是在合适的地方使用 exit() 来退出 App.</li></ol><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li><a href="https://www.iana.org/assignments/media-types/media-types.xhtml" target="_blank" rel="noopener">MIMEType IANA</a></li><li><a href="https://www.freeformatter.com/mime-types-list.html#mime-types-list" target="_blank" rel="noopener">MIMEType to Extension</a></li><li><a href="https://forums.developer.apple.com/thread/14854" target="_blank" rel="noopener">NSURLSession’s Resume Rate Limiter</a></li><li><a href="https://forums.developer.apple.com/thread/14855" target="_blank" rel="noopener">Testing Background Session Code</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;当初编写 0.x 版本时, 尚未考虑过多逻辑, 整体架构就是简单的封装系统逻辑, 导致在后期频频出问题, 而打补丁只会出更多的问题, 毕竟底子并没有打好, 所以就起了重构的心思.&lt;/p&gt;
    
    </summary>
    
      <category term="开发学习" scheme="http://norld.com/categories/%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="iOS" scheme="http://norld.com/tags/iOS/"/>
    
      <category term="后台下载" scheme="http://norld.com/tags/%E5%90%8E%E5%8F%B0%E4%B8%8B%E8%BD%BD/"/>
    
      <category term="FKDownloader" scheme="http://norld.com/tags/FKDownloader/"/>
    
      <category term="NSURLSession" scheme="http://norld.com/tags/NSURLSession/"/>
    
      <category term="NSURLDownloadTask" scheme="http://norld.com/tags/NSURLDownloadTask/"/>
    
      <category term="重构" scheme="http://norld.com/tags/%E9%87%8D%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>iOS 开发小技巧 ---- Masonry 中使用 Margin</title>
    <link href="http://norld.com/2019/05/22/Masonry%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <id>http://norld.com/2019/05/22/Masonry小技巧/</id>
    <published>2019-05-22T07:38:50.000Z</published>
    <updated>2019-05-22T07:51:45.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iOS-开发小技巧-—-Masonry-中使用-Margin"><a href="#iOS-开发小技巧-—-Masonry-中使用-Margin" class="headerlink" title="iOS 开发小技巧 —- Masonry 中使用 Margin"></a>iOS 开发小技巧 —- Masonry 中使用 Margin</h1><p>为了让界面的布局显示正确, 并且在异形屏上显示正确, 那真是无所不用其极, 什么 <code>edgesForExtendedLayout</code>, <code>automaticallyAdjustsScrollViewInsets</code>, <code>insetsLayoutMarginsFromSafeArea</code>, <code>contentInsetAdjustmentBehavior</code>, <code>autoresizingMask</code> 还有 <code>safeArea</code>, 统统都有用, 但个个都很麻烦, 甚至复杂的界面还会出现设置无效的情况. 那么, 有没有一个一劳永逸的方法呢?</p><p>有, <code>Masonry</code> 或者 <code>AutoLayout</code> 中的带有 <code>Margin</code> 后缀的约束</p><a id="more"></a><h1 id="先搭一个简单界面做测试"><a href="#先搭一个简单界面做测试" class="headerlink" title="先搭一个简单界面做测试"></a>先搭一个简单界面做测试</h1><h2 id="带有-UINavigationController-UIView-坐标偏上"><a href="#带有-UINavigationController-UIView-坐标偏上" class="headerlink" title="带有 UINavigationController, UIView 坐标偏上"></a>带有 <code>UINavigationController</code>, <code>UIView</code> 坐标偏上</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[self.testView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">    make.top.equalTo(self.view.mas_top);</span><br><span class="line">    make.left.equalTo(self.view.mas_left);</span><br><span class="line">    make.width.mas_equalTo(100);</span><br><span class="line">    make.height.mas_equalTo(100);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/05/22/5ce4ef51814e494325.jpg" alt="iPhone 8p 上的效果"><br>这是典型的 <code>UINavigationController</code> 遮挡, 让我们稍微修改一下约束:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[self.testView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">    make.top.equalTo(self.view.mas_topMargin); // 修改为 Margin</span><br><span class="line">    make.left.equalTo(self.view.mas_left);</span><br><span class="line">    make.width.mas_equalTo(100);</span><br><span class="line">    make.height.mas_equalTo(100);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p></p><p><img src="https://i.loli.net/2019/05/22/5ce4f0c4efa4417365.png" alt="iPhone 8p 上的效果"><br>完美! 再来看看异形屏上的效果对比<br><img src="https://i.loli.net/2019/05/22/5ce4f1f6ae1fc64465.png" alt="iPhone Xr 修改前"><br>修改后<br><img src="https://i.loli.net/2019/05/22/5ce4f1f86ace522625.png" alt="iPhone Xr 修改后"></p><h2 id="带有-UItabBarController-UIView-坐标偏下"><a href="#带有-UItabBarController-UIView-坐标偏下" class="headerlink" title="带有 UItabBarController, UIView 坐标偏下"></a>带有 <code>UItabBarController</code>, <code>UIView</code> 坐标偏下</h2><p>修改前<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[self.testView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">    make.bottom.equalTo(self.view.mas_bottom);</span><br><span class="line">    make.left.equalTo(self.view.mas_left);</span><br><span class="line">    make.width.mas_equalTo(200);</span><br><span class="line">    make.height.mas_equalTo(100);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p></p><p><img src="https://i.loli.net/2019/05/22/5ce4f4b28d52f40266.png" alt="iPhone 8p"><br>修改后<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[self.testView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">    make.bottom.equalTo(self.view.mas_bottomMargin);</span><br><span class="line">    make.left.equalTo(self.view.mas_left);</span><br><span class="line">    make.width.mas_equalTo(200);</span><br><span class="line">    make.height.mas_equalTo(100);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p></p><p><img src="https://i.loli.net/2019/05/22/5ce4f4b289b6960944.png" alt="iPhone 8p"></p><h2 id="没有-UItabBarController-UIView-坐标偏下-异形屏"><a href="#没有-UItabBarController-UIView-坐标偏下-异形屏" class="headerlink" title="没有 UItabBarController, UIView 坐标偏下, 异形屏"></a>没有 <code>UItabBarController</code>, <code>UIView</code> 坐标偏下, 异形屏</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[self.testView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">    make.bottom.equalTo(self.view.mas_bottom);</span><br><span class="line">    make.left.equalTo(self.view.mas_left);</span><br><span class="line">    make.width.mas_equalTo(200);</span><br><span class="line">    make.height.mas_equalTo(100);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/05/22/5ce4f306c9bcb71158.png" alt="iPhone Xr 上的效果"><br>美工: 我这张PSD下去, 你可能会死<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[self.testView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">    make.bottom.equalTo(self.view.mas_bottomMargin); // 修改为 Margin</span><br><span class="line">    make.left.equalTo(self.view.mas_left);</span><br><span class="line">    make.width.mas_equalTo(200);</span><br><span class="line">    make.height.mas_equalTo(100);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p></p><p><img src="https://i.loli.net/2019/05/22/5ce4f567b5a5178725.png" alt="iPhone Xr 修改后的显示"><br>完美!</p><h2 id="带有-UItabBarController-UIView-坐标偏下-异形屏"><a href="#带有-UItabBarController-UIView-坐标偏下-异形屏" class="headerlink" title="带有 UItabBarController, UIView 坐标偏下, 异形屏"></a>带有 <code>UItabBarController</code>, <code>UIView</code> 坐标偏下, 异形屏</h2><p>修改前<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[self.testView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">    make.bottom.equalTo(self.view.mas_bottom);</span><br><span class="line">    make.left.equalTo(self.view.mas_left);</span><br><span class="line">    make.width.mas_equalTo(200);</span><br><span class="line">    make.height.mas_equalTo(100);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p></p><p><img src="https://i.loli.net/2019/05/22/5ce4f69a6fd7037550.png" alt="iPhone Xr 修改前"><br>修改后<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[self.testView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">    make.bottom.equalTo(self.view.mas_bottomMargin);</span><br><span class="line">    make.left.equalTo(self.view.mas_left);</span><br><span class="line">    make.width.mas_equalTo(200);</span><br><span class="line">    make.height.mas_equalTo(100);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p></p><p><img src="https://i.loli.net/2019/05/22/5ce4f69a8896186021.png" alt="iPhone Xr 修改后"></p><h4 id="如果将-UIView-换成-UITableView-呢"><a href="#如果将-UIView-换成-UITableView-呢" class="headerlink" title="如果将 UIView 换成 UITableView 呢?"></a>如果将 <code>UIView</code> 换成 <code>UITableView</code> 呢?</h4><p>只要使用自动布局, 加不加 Margin 都一样, 因为系统会自动将 <code>-[UIViwController view]</code> 上第一个 <code>UIScrollView</code> 进行自动的边距处理, 但如果使用了别的布局属性来规避某些显示异常, 比如 <code>edgesForExtendedLayout</code>, <code>automaticallyAdjustsScrollViewInsets</code>, <code>contentInsetAdjustmentBehavior</code> 或者 <code>autoresizingMask</code>, 就可以使用 Margin 约束试一试, 指不定会有惊喜哦.</p><h4 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h4><p>带有 <code>Margin</code> 的约束目前只能在 iOS 8.0 及以上, iPhone 上使用, 已经可以覆盖99.99%以上的系统和设备, 可以没有后顾之忧的使用.</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;iOS-开发小技巧-—-Masonry-中使用-Margin&quot;&gt;&lt;a href=&quot;#iOS-开发小技巧-—-Masonry-中使用-Margin&quot; class=&quot;headerlink&quot; title=&quot;iOS 开发小技巧 —- Masonry 中使用 Margin&quot;&gt;&lt;/a&gt;iOS 开发小技巧 —- Masonry 中使用 Margin&lt;/h1&gt;&lt;p&gt;为了让界面的布局显示正确, 并且在异形屏上显示正确, 那真是无所不用其极, 什么 &lt;code&gt;edgesForExtendedLayout&lt;/code&gt;, &lt;code&gt;automaticallyAdjustsScrollViewInsets&lt;/code&gt;, &lt;code&gt;insetsLayoutMarginsFromSafeArea&lt;/code&gt;, &lt;code&gt;contentInsetAdjustmentBehavior&lt;/code&gt;, &lt;code&gt;autoresizingMask&lt;/code&gt; 还有 &lt;code&gt;safeArea&lt;/code&gt;, 统统都有用, 但个个都很麻烦, 甚至复杂的界面还会出现设置无效的情况. 那么, 有没有一个一劳永逸的方法呢?&lt;/p&gt;&lt;p&gt;有, &lt;code&gt;Masonry&lt;/code&gt; 或者 &lt;code&gt;AutoLayout&lt;/code&gt; 中的带有 &lt;code&gt;Margin&lt;/code&gt; 后缀的约束&lt;/p&gt;
    
    </summary>
    
      <category term="开发学习" scheme="http://norld.com/categories/%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="iOS" scheme="http://norld.com/tags/iOS/"/>
    
      <category term="Masonry" scheme="http://norld.com/tags/Masonry/"/>
    
      <category term="自动布局" scheme="http://norld.com/tags/%E8%87%AA%E5%8A%A8%E5%B8%83%E5%B1%80/"/>
    
      <category term="小技巧" scheme="http://norld.com/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>搭建 Docker + Flask 后端</title>
    <link href="http://norld.com/2018/12/26/DockerFlaskApi/"/>
    <id>http://norld.com/2018/12/26/DockerFlaskApi/</id>
    <published>2018-12-26T07:38:50.000Z</published>
    <updated>2019-04-28T15:23:49.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="搭建-Docker-Flask-后端"><a href="#搭建-Docker-Flask-后端" class="headerlink" title="搭建 Docker + Flask 后端"></a>搭建 Docker + Flask 后端</h1><p>使用 Docker + Flask + Gunicorn + Gevent + nginx 来搭建纯 API 后端</p><h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>使用 Docker 编排管理服务, 使用 Shell 脚本一键化部署流程</p><a id="more"></a><h1 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h1><p>创建目录/文件, 结构如下:</p><p>site<br>|– flask<br>&nbsp;&nbsp;&nbsp;&nbsp;|– Dockerfile<br>&nbsp;&nbsp;&nbsp;&nbsp;|– server<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|– config<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|– gunicorn.conf.py<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|– app.py<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|– requirements.txt<br>|– nginx<br>&nbsp;&nbsp;&nbsp;&nbsp;|– default.conf<br>|– docker-compose.yml<br>|– deploy.sh</p><h1 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h1><h4 id="flask-Dockerfile"><a href="#flask-Dockerfile" class="headerlink" title="flask/Dockerfile"></a>flask/Dockerfile</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">FROM python:3.7</span><br><span class="line"></span><br><span class="line">COPY ./server /workspace</span><br><span class="line">WORKDIR /workspace</span><br><span class="line"></span><br><span class="line">RUN pip install -i https://mirrors.aliyun.com/pypi/simple/ --upgrade pip \</span><br><span class="line">&amp;&amp; pip --no-cache-dir install -i https://mirrors.aliyun.com/pypi/simple/ -r requirements.txt</span><br><span class="line"></span><br><span class="line">EXPOSE 5000</span><br><span class="line"></span><br><span class="line">CMD [&quot;gunicorn&quot;, &quot;app:app&quot;, &quot;-c&quot;, &quot;./config/gunicorn.conf.py&quot;]</span><br></pre></td></tr></table></figure><h4 id="flask-server-requirements-txt"><a href="#flask-server-requirements-txt" class="headerlink" title="flask/server/requirements.txt"></a>flask/server/requirements.txt</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Flask==1.0.2</span><br><span class="line">gunicorn==19.9.0</span><br><span class="line">gevent==1.4.0</span><br></pre></td></tr></table></figure><h4 id="flask-server-app-py"><a href="#flask-server-app-py" class="headerlink" title="flask/server/app.py"></a>flask/server/app.py</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from flask import Flask</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">@app.route(&apos;/&apos;)</span><br><span class="line">def hello_world():</span><br><span class="line">    return &apos;Hello, World!&apos;</span><br></pre></td></tr></table></figure><h4 id="flask-server-config-gunicorn-conf-py"><a href="#flask-server-config-gunicorn-conf-py" class="headerlink" title="flask/server/config/gunicorn.conf.py"></a>flask/server/config/gunicorn.conf.py</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">workers = 5</span><br><span class="line">worker_class = &quot;gevent&quot;</span><br><span class="line">bind = &quot;0.0.0.0:5000&quot;</span><br><span class="line">loglevel = &apos;debug&apos;</span><br></pre></td></tr></table></figure><h4 id="nginx-default-conf"><a href="#nginx-default-conf" class="headerlink" title="nginx/default.conf"></a>nginx/default.conf</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name api.site.com;</span><br><span class="line">    listen [::]:80;</span><br><span class="line">    server_tokens off;</span><br><span class="line">    client_max_body_size 15M;</span><br><span class="line"></span><br><span class="line">    access_log  /var/log/nginx/nginx.api.access.log;</span><br><span class="line">    error_log   /var/log/nginx/nginx.api.error.log;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_set_header Host $http_host;</span><br><span class="line">        proxy_set_header X-NginX-Proxy true;</span><br><span class="line"></span><br><span class="line">        proxy_pass http://flask:5000;</span><br><span class="line">        proxy_redirect off;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="docker-compose-yml"><a href="#docker-compose-yml" class="headerlink" title="docker-compose.yml"></a>docker-compose.yml</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line">services:</span><br><span class="line">  nginx:</span><br><span class="line">    image: nginx:alpine</span><br><span class="line">    volumes:</span><br><span class="line">      - ./nginx:/etc/nginx/conf.d</span><br><span class="line">      - /var/log/nginx:/var/log/nginx</span><br><span class="line">    links:</span><br><span class="line">      - flask</span><br><span class="line">    ports:</span><br><span class="line">      - 80:80</span><br><span class="line">  flask:</span><br><span class="line">    build:</span><br><span class="line">      context: ./flask</span><br></pre></td></tr></table></figure><h4 id="deploy-sh"><a href="#deploy-sh" class="headerlink" title="deploy.sh"></a>deploy.sh</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">rm -rf &apos;tmp.tar&apos;</span><br><span class="line">cd &apos;..&apos;</span><br><span class="line">tar cf &apos;tmp.tar&apos; &apos;site&apos;</span><br><span class="line">mv &apos;tmp.tar&apos; &apos;site/tmp.tar&apos;</span><br><span class="line">cd &apos;site&apos;</span><br><span class="line"></span><br><span class="line">sftp &apos;root@api.norld.com&apos; &lt;&lt;EOF</span><br><span class="line">cd &apos;/root&apos;</span><br><span class="line">put &apos;tmp.tar&apos;</span><br><span class="line">exit</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">rm -rf &apos;tmp.tar&apos;</span><br><span class="line"></span><br><span class="line">ssh &apos;user@api.site.com&apos; &lt;&lt;EOF</span><br><span class="line">rm -rf &apos;site&apos;</span><br><span class="line">tar xf &apos;tmp.tar&apos;</span><br><span class="line">cd &apos;site&apos;</span><br><span class="line">docker-compose down</span><br><span class="line">docker-compose up --build -d</span><br><span class="line">echo &apos;y&apos; | docker image prune</span><br><span class="line">exit</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h1 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h1><p>将部分参数替换成你需要的, 终端执行 deploy.sh, 开始访问 <a href="http://api.site.com" target="_blank" rel="noopener">http://api.site.com</a>, Hello, World!</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;搭建-Docker-Flask-后端&quot;&gt;&lt;a href=&quot;#搭建-Docker-Flask-后端&quot; class=&quot;headerlink&quot; title=&quot;搭建 Docker + Flask 后端&quot;&gt;&lt;/a&gt;搭建 Docker + Flask 后端&lt;/h1&gt;&lt;p&gt;使用 Docker + Flask + Gunicorn + Gevent + nginx 来搭建纯 API 后端&lt;/p&gt;&lt;h1 id=&quot;目标&quot;&gt;&lt;a href=&quot;#目标&quot; class=&quot;headerlink&quot; title=&quot;目标&quot;&gt;&lt;/a&gt;目标&lt;/h1&gt;&lt;p&gt;使用 Docker 编排管理服务, 使用 Shell 脚本一键化部署流程&lt;/p&gt;
    
    </summary>
    
      <category term="开发学习" scheme="http://norld.com/categories/%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Server" scheme="http://norld.com/tags/Server/"/>
    
      <category term="Docker" scheme="http://norld.com/tags/Docker/"/>
    
      <category term="Flask" scheme="http://norld.com/tags/Flask/"/>
    
      <category term="Gunicorn" scheme="http://norld.com/tags/Gunicorn/"/>
    
      <category term="Gevent" scheme="http://norld.com/tags/Gevent/"/>
    
      <category term="nginx" scheme="http://norld.com/tags/nginx/"/>
    
      <category term="后端" scheme="http://norld.com/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>解决 xcode 10 移除 libstdc++ 导致的 file not found 错误</title>
    <link href="http://norld.com/2018/12/26/xcode-10-libstdc++/"/>
    <id>http://norld.com/2018/12/26/xcode-10-libstdc++/</id>
    <published>2018-12-26T07:38:50.000Z</published>
    <updated>2019-10-21T02:36:41.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><p>　　解决 xcode 10 移除 libstdc++ 库, 替换为 libc++ 库而导致无法找到头文件的问题.</p><a id="more"></a><h4 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h4><ol><li><p>准备数据, 拉取 <a href="https://github.com/SYFH/Xcode_libstdc.git" target="_blank" rel="noopener">Xcode_libstdc</a> 到本地.</p></li><li><p>进入项目根目录, 执行 install.sh 脚本, 脚本会自动获取 CLT 对应的 Xcode 路径进行安装. 如果存在多个 Xcode, 请在 Xcode 设置中修改 Command Line Tools 版本号, 脚本只会对已选择的版本进行安装.</p></li><li><p><font color="red"><strong>[此步骤必须执行]</strong></font> 打开需要 libstdc++ 的项目, 选择 Xcode -&gt; File -&gt; Workspace Setting… -&gt; Build System, 选择 Legacy Build System, 重新编译.</p></li><li><p>完成! 开始运行!</p></li></ol><h4 id="参考"><a href="#参考" class="headerlink" title="参考:"></a>参考:</h4><ol><li><a href="https://stackoverflow.com/a/53644801" target="_blank" rel="noopener">stackoverflow ld: library not found for -lstdc++.6</a></li><li><a href="https://stackoverflow.com/a/52757858" target="_blank" rel="noopener">stackoverflow Xcode 10 (iOS 12) does not contain libstdc++6.0.9</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;目标&quot;&gt;&lt;a href=&quot;#目标&quot; class=&quot;headerlink&quot; title=&quot;目标&quot;&gt;&lt;/a&gt;目标&lt;/h4&gt;&lt;p&gt;　　解决 xcode 10 移除 libstdc++ 库, 替换为 libc++ 库而导致无法找到头文件的问题.&lt;/p&gt;
    
    </summary>
    
      <category term="开发学习" scheme="http://norld.com/categories/%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="iOS" scheme="http://norld.com/tags/iOS/"/>
    
      <category term="xcode" scheme="http://norld.com/tags/xcode/"/>
    
      <category term="libstdc++" scheme="http://norld.com/tags/libstdc/"/>
    
      <category term="libc++" scheme="http://norld.com/tags/libc/"/>
    
  </entry>
  
  <entry>
    <title>一个系统BUG引发的血案 -- FKDownloader</title>
    <link href="http://norld.com/2018/11/29/FKDownloader/"/>
    <id>http://norld.com/2018/11/29/FKDownloader/</id>
    <published>2018-11-29T13:52:30.000Z</published>
    <updated>2018-11-29T13:54:46.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="接触-BUG"><a href="#接触-BUG" class="headerlink" title="接触 BUG"></a>接触 BUG</h4><p>　　前几天突然收到一朋友发来的消息, 说是在 iOS 12 上遇到了一个新的 BUG, 问我怎么看? 我说新系统遇到 BUG 不是很正常吗? 大概是个什么情况?<br>　　经过朋友说明, 大概是这么个现象: 他用了一个第三方下载管理器进行视频下载, 明明是设置了后台下载的, 但 App 一推到后台再回到前台, 下载进度就不动了, 但任务依然还在继续下载. 系统是 iOS 12, 手机是 iPhone 7.<br>　　<br>　　<a id="more"></a></p><h4 id="BUG-详情"><a href="#BUG-详情" class="headerlink" title="BUG 详情"></a>BUG 详情</h4><p>　　刚一开始还以为第三方在进度处理方面写的有问题, 但我把这个第三方的 <a href="https://github.com/XXDownload/XXDownload" target="_blank" rel="noopener">Demo</a> 下载运行后, 发现这根本不是第三方问题, 而是系统问题, 系统代理 <code>-[NSURLSessionDownloadTask URLSession:downloadTask:didWriteData:totalBytesWritten:totalBytesExpectedToWrite:]</code> 根本没有被调用, 所以下载进度根本就无法继续计算.<br>　　然后我改为使用 KVO 监听 <code>NSURLSessionDownloadTask</code> 的 <code>countOfBytesReceived</code> 和 <code>countOfBytesExpectedToReceive</code> 属性来计算当前下载进度, 但很遗憾, 这两个值在重回前台后就没在继续变化, 初步认定是系统在处理数据接收时出现了异常, 导致省略了值的改变, 还有顺便躺枪的进度代理.<br>　　上一次遇到这种系统犯法失效的 BUG 还是在 iOS 11.1/11.2 上, 当时开发录屏直播, 系统方法 <code>-[RPBroadcastSampleHandler processSampleBuffer:withType:]</code> 没有被调用, 直接坑掉了一个大功能模块, 但幸好, 这一回遇到的 BUG 不算严重, 解决方法还是有的.</p><h4 id="开始测试"><a href="#开始测试" class="headerlink" title="开始测试"></a>开始测试</h4><p>　　这回的进度 BUG 在虚拟机上是不会出现的, 必须真机, 而且经过测试, 发现只在 iOS 12/12.1, iPhone 8 以下才会出现.<br>　　在测试时还发现 App 完全退出后, 后台下载任务会直接取消, 但是带有恢复数据.<br>　　进入前台后, 手动进行 <code>暂停-&gt;继续</code> 操作后, 代理/KVO 就会继续工作.</p><h4 id="尝试修复-BUG"><a href="#尝试修复-BUG" class="headerlink" title="尝试修复 BUG"></a>尝试修复 BUG</h4><p>　　既然手动 <code>暂停-&gt;继续</code> 可以修复 BUG, 那只要用代码重现一遍就可以了吧? 别急, 事情没有那么简单.<br>　　直接在 <code>-[AppDelegate applicationWillEnterForeground:]</code> 开始遍历所有下载任务, 都执行一遍 <code>暂停-&gt;继续</code> 操作, 这个方法很简单, 很粗暴, 但, 这不管用!<br>　　那么使用 <code>-[NSURLSessionDownloadTask cancelByProducingResumeData:]</code> -&gt; <code>-[NSURLSession downloadTaskWithResumeData:]</code> 代替 <code>暂停-&gt;继续</code> 呢? 不错, 意识到当前的 <code>NSURLSessionDownloadTask</code> 可能存在脏数据是个进步, 但, 这依然不管用!</p><p><img src="https://user-gold-cdn.xitu.io/2018/11/23/1673fc0c1cecf0ab?w=300&amp;h=186&amp;f=gif&amp;s=2049669" alt="系统的BUG"></p><p>　　最后的最后, 还是测试出来了, 必须在 <code>[AppDelegate applicationDidBecomeActive:]</code> 里面遍历使用 <code>取消-&gt;恢复</code> 才能成功</p><h4 id="关于下载器的轮子"><a href="#关于下载器的轮子" class="headerlink" title="关于下载器的轮子"></a>关于下载器的轮子</h4><p>　　朋友说你写一个下载第三方吧, 现在的下载器没几个好用的. 当时我还不以为然, 说是 GitHub 上那么多轮子, 不缺我这一个, 而且就算写了也不一定比热门的好, 实在不行还有 <code>AFNetworking</code> 当打底的.<br>　　我在很久以前我就打算写一个下载器, 想要重点实现单文件多线程分片下载, 当时数据流下载已经写完了, 数据拼接也基本完成了, 准备支持后台下载才发现, <code>NSURLSessionDataTask</code> 不支持后台下载!!! 好吧, Apple🐂🍺🤪<br>　　我也看了我朋友用的 <a href="https://github.com/XXDownload/XXDownload" target="_blank" rel="noopener">XXDownload</a>, 虽然 star 少了点, 但这个刚好符合需求. 虽然在实现中大范围使用下划线变量, 而且还在单例上使用代理, 感觉一口老血卡在喉咙里, 但至少改改还是能用的, 毕竟这种第三方也就是提供个框架而已.<br>　　而在 GitHub 上, 已经有一堆项目停止维护了, 还在更新的, 因为任务持久化使用了数据库, 引用了其他第三方, 可能导致库冲突, 而那些还在持续维护的纯净版又无法适应一些需求场景.<br>　　其中 <a href="https://github.com/Heikowi/HWIFileDownload" target="_blank" rel="noopener">HWIFileDownload</a> 就属于一直在更新, 也很纯净的第三方, 一般项目使用足以胜任. 但在某些特殊需求上就有点相形见绌了, 比如支持时效性下载链接, 持久化任务列表, 文件校验, 对恢复数据深度处理等.<br>　　当然, 这都不是重点, 重点是后台下载场景太稀少了, 自己随手写一个都可以勉强用, 还要什么第三方, 这种吃力不讨好, 还基本没有 Star 的操作我是不会做的.</p><p><img src="https://user-gold-cdn.xitu.io/2018/11/23/1673fc0c1cd5ac60?w=300&amp;h=184&amp;f=gif&amp;s=1019169" alt="真香"></p><h4 id="FKDownloader-–-最终还是写了"><a href="#FKDownloader-–-最终还是写了" class="headerlink" title="FKDownloader – 最终还是写了"></a>FKDownloader – 最终还是写了</h4><p>既然都写出来了, 那就必须尽量完美, 除了修复/规避 iOS 的 BUG, 当然还需要支持一些特别的需求.<br>先列一下 FKDownloader 的整体结构:</p><ul><li><p>主类</p><ul><li><p>FKDownloadManager</p><ul><li>自加载, 不必显式调用创建单例</li><li>不可继承, 唯一存在</li><li>管理 Task, 进行增删查操作</li><li>开始/暂停/恢复/取消 Task, 但实现与状态过滤全权由 Task 实现</li><li>所有任务下载进度</li><li>在 AppDelegate 处理部分功能, 如后台下载, 加载任务归档, 解决 iOS BUG 等</li></ul></li><li><p>FKConfigure</p><ul><li>统一管理特殊配置</li><li>设置 Session Identifier</li><li>设置是否为后台下载</li><li>设置是否自动清理已完成/失败任务</li><li>设置是否自动开始任务, 针对载入本地归档任务时</li><li>自定义请求超时时间</li></ul></li><li><p>FKTask</p><ul><li>开始/暂停/恢复/取消的具体实现</li><li>Block/Delegate/Notification 的发起者</li><li>校验文件</li><li>下载速度/预计剩余时间</li><li>可添加附带信息, 包括保存文件名, 校验信息, 自定义请求头等信息</li></ul></li></ul></li><li><p>辅类</p><ul><li>FKResumeHelper<ul><li>解包/封包恢复数据</li><li>修复 iOS 特定版本中错误的恢复数据</li><li>更新恢复数据的 URL</li></ul></li></ul></li><li><p>其他</p><ul><li>FKDefine: 声明枚举, C 方法, 字符串常量</li><li>FKReachability: 网络状态检测与监听</li><li>FKDownloadExecutor: 统一处理系统代理</li><li>FKTaskStorage: 管理任务的归解档</li><li>FKHashHelper: 计算 Hash</li><li>FKSystemHelper: 获取设备版本, 系统版本</li></ul></li></ul><p>FKDownloader 不依赖其他任何第三方, 保持纯净性, 其中的方法大部分都偏向于对外简单, 对内复杂, 而且尽量避免高耦合.</p><h4 id="FKDownloader-支持与安装"><a href="#FKDownloader-支持与安装" class="headerlink" title="FKDownloader 支持与安装"></a>FKDownloader 支持与安装</h4><p>必须 iOS 8 以上, 使用 ARC.<br>支持 <code>CocoaPods</code> 和 <code>Carthage</code> 安装.<br>如有其他需求, 可直接将 <code>FKDownloader</code> 文件夹直接放入项目中.</p><h4 id="FKDownloader-特点"><a href="#FKDownloader-特点" class="headerlink" title="FKDownloader 特点"></a>FKDownloader 特点</h4><ul><li>自加载<br>　　使用 <code>+[NSObject load]</code> 加载单例, 不必再显式调用来创建单例. 因此可以提前监听 <code>AppDelegate</code> 通知, 修复进度 BUG 将可以自处理, 不必显示调用.</li><li><p>重启 App 时恢复下载中任务进度<br>　　也就是开始一个后台下载任务, 完全退出 App 后再次运行 App, 需要重新拿到下载任务的进度与状态, 以达到 UI 上显示任务还在运行中的效果.<br>　　实现这个功能的第三方我只见到一两个, 这其中的重点是 <code>-[NSURLSession getTasksWithCompletionHandler:]</code> 这个系统方法, 它可以将带有 <code>identifier</code> 的 <code>NSURLSession</code> 中所有的后台任务获取到.</p></li><li><p>支持时效性 URL<br>　　获取到 FKTask 后, 可直接通过 <code>-[FKTask resumeFilePath]</code> 获取 ResumeData 保存路径, 之后用 <code>+[FKResumeHelper updateResumeData:url:]</code> 拿到更新后的 ResumeData, 再保存后即可.<br>　　也可以直接使用 <code>-[FKTask updateURL:]</code> 直接更新, 但对进行中的任务无效, 且必须已存在恢复数据.<br>　　FKDownloader 只使用 URL 的 <code>scheme://host/path</code> 创建标识符, 所以参数可以随意修改, 如果是使用请求头完成过期操作的, 可使用自定义请求头.</p></li><li><p>根据网络状态执行特定操作<br>　　检测当前网络状态, 如果没有网络则暂停进行中任务, 取消等待中任务.<br>　　当恢复网络时, 就会将因为无网络而中断的任务继续下载.</p></li><li><p>使用 <code>NSCoding</code> 持久化下载任务, 不依赖数据库<br>　　直接保存任务信息, 包括 URL, 任务状态, 保存文件名, 校验信息, 自定义请求头, 文件总大小, 已接收字节数等信息, 保证重启 App 后 UI 信息和退出 App 前保持一致.<br>　　代价就是不能高度自定义要保存的数据, 但 <code>FKTask</code> 向外暴露的属性完全满足外接式数据处理需求, 也可以使用项目中已存在的数据库进行自定义管理.</p></li><li><p>预见性处理状态/进度<br>　　设置代理时会将当前所有协议方法触发一遍, 保证 UI 获取的信息为最新.</p></li><li>任务状态/进度的监听<br>　　可以自由使用 Block/Delegate/Notification 获取, 最大化覆盖应用场景.</li><li>自定义任务附加信息<br>　　目前支持保存文件名, 文件校验值, 自定义请求头.</li><li>支持 URL 中参数可变<br>　　<code>FKTask</code> 只使用 <code>scheme://host/path</code> 创建标识符, <code>parameters</code> 信息将直接忽略, 以识别时效性 URL 下载任务.</li><li>精细任务状态<br>　　无/预处理/等待/进行中/完成/取消/暂停/恢复/校验/错误, 基本上都有 <code>will</code> 和 <code>did</code> 双重级别.</li><li>文件校验<br>　　支持 MD5, SHA1, SHA256, SHA512, 但校验特大文件时, CPU占用过大, 所以默认配置为关闭验证.</li><li>兼容 Swift<br>　　支持在 Swift 项目中进行使用.</li></ul><h4 id="FKDownloader-简单使用"><a href="#FKDownloader-简单使用" class="headerlink" title="FKDownloader 简单使用"></a>FKDownloader 简单使用</h4><ul><li>任务管理</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// 添加任务, 但不执行, 适合批量添加任务的场景</span><br><span class="line">[[FKDownloadManager manager] add:@“URL”];</span><br><span class="line"></span><br><span class="line">// 添加任务, 并附加额外信息, 目前支持 URL, 自定义保存文件名, 校验值, 校验类型, 自定义请求头</span><br><span class="line">[[FKDownloadManager manager] addInfo:@&#123;FKTaskInfoURL: url,</span><br><span class="line">                                       FKTaskInfoFileName: @&quot;xCode7&quot;,</span><br><span class="line">                                       FKTaskInfoVerificationType: @(VerifyTypeMD5),</span><br><span class="line">                                       FKTaskInfoVerification: @&quot;5f75fe52c15566a12b012db21808ad8c&quot;,</span><br><span class="line">                                       FKTaskInfoRequestHeader: @&#123;&#125; &#125;];</span><br><span class="line"></span><br><span class="line">// 开始执行任务</span><br><span class="line">[[FKDownloadManager manager] start:@“URL”];</span><br><span class="line"></span><br><span class="line">// 根据 URL 获取任务</span><br><span class="line">[[FKDownloadManager manager] acquire:@“URL”];</span><br><span class="line"></span><br><span class="line">// 暂停任务</span><br><span class="line">[[FKDownloadManager manager] suspend:@“URL”];</span><br><span class="line"></span><br><span class="line">// 恢复任务</span><br><span class="line">[[FKDownloadManager manager] resume:@“URL”];</span><br><span class="line"></span><br><span class="line">// 取消任务</span><br><span class="line">[[FKDownloadManager manager] cancel:@“URL”];</span><br><span class="line"></span><br><span class="line">// 移除任务</span><br><span class="line">[[FKDownloadManager manager] remove:@“URL”];</span><br><span class="line"></span><br><span class="line">// 设置任务代理</span><br><span class="line">[[FKDownloadManager manager] acquire:@“URL”].delegate = self;</span><br><span class="line"></span><br><span class="line">// 设置任务 Block</span><br><span class="line">[[FKDownloadManager manager] acquire:@“URL”].statusBlock = ^(FKTask *task) &#123;</span><br><span class="line">    // 状态改变时被调用</span><br><span class="line">&#125;;</span><br><span class="line">[[FKDownloadManager manager] acquire:@“URL”].speedBlock = ^(FKTask *task) &#123;</span><br><span class="line">    // 下载速度, 默认 1s 调用一次</span><br><span class="line">&#125;;</span><br><span class="line">[[FKDownloadManager manager] acquire:@“URL”].progressBlock = ^(FKTask *task) &#123;</span><br><span class="line">    // 进度改变时被调用</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>支持的任务通知</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 与代理同价, 可按照代理的使用方式使用通知.</span><br><span class="line">extern FKNotificationName const FKTaskPrepareNotification;</span><br><span class="line">extern FKNotificationName const FKTaskDidIdleNotification;</span><br><span class="line">extern FKNotificationName const FKTaskWillExecuteNotification;</span><br><span class="line">extern FKNotificationName const FKTaskDidExecuteNotication;</span><br><span class="line">extern FKNotificationName const FKTaskProgressNotication;</span><br><span class="line">extern FKNotificationName const FKTaskDidResumingNotification;</span><br><span class="line">extern FKNotificationName const FKTaskWillChecksumNotification;</span><br><span class="line">extern FKNotificationName const FKTaskDidChecksumNotification;</span><br><span class="line">extern FKNotificationName const FKTaskDidFinishNotication;</span><br><span class="line">extern FKNotificationName const FKTaskErrorNotication;</span><br><span class="line">extern FKNotificationName const FKTaskWillSuspendNotication;</span><br><span class="line">extern FKNotificationName const FKTaskDidSuspendNotication;</span><br><span class="line">extern FKNotificationName const FKTaskWillCancelldNotication;</span><br><span class="line">extern FKNotificationName const FKTaskDidCancelldNotication;</span><br><span class="line">extern FKNotificationName const FKTaskSpeedInfoNotication;</span><br></pre></td></tr></table></figure><ul><li>需要在 AppDelegate 中调用的</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)application:(UIApplication *)application handleEventsForBackgroundURLSession:(NSString *)identifier completionHandler:(void (^)(void))completionHandler &#123;</span><br><span class="line">    </span><br><span class="line">    // 保存后台下载所需的系统 Block, 区别 identifier 以防止与其他第三方冲突</span><br><span class="line">    if ([identifier isEqualToString:[FKDownloadManager manager].configure.sessionIdentifier]) &#123;</span><br><span class="line">        [FKDownloadManager manager].configure.backgroundHandler = completionHandler;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="FKDownloader-处理的一些细节"><a href="#FKDownloader-处理的一些细节" class="headerlink" title="FKDownloader 处理的一些细节"></a>FKDownloader 处理的一些细节</h4><ul><li>ResumeData<br>　　恢复数据在 iOS 10.0/10.1 中出现了格式错误, 官方在 iOS 10.2 中修复成功, 但为了兼容, 还是需要修复一番的, 具体解决方案在<a href="https://stackoverflow.com/questions/39346231/resume-nsurlsession-on-ios10/39347461#39347461" target="_blank" rel="noopener">这里</a>.<br>　　而在 iOS 11 中, 因为多出了 <code>NSURLSessionResumeByteRange</code> 字段导致一些奇怪的问题, 可以使用 <code>FKResumeHelper</code> 先读取, 在删除字段, 然后封包, 也可自己进行删除, 目前 FKDownloader 已自行处理.<br>　　虽然没有出错, 但在 iOS 12 中, ResumeData 的封包格式发生了改变, <del>现在可使用 <code>+[NSKeyedUnarchiver unarchiveObjectWithData:]</code> 直接进行解包</del>, 现在可以使用 <code>-[NSKeyedUnarchiver decodeTopLevelObjectForKey:error:]</code> 方法, <code>key</code> 为 <code>NSKeyedArchiveRootObjectKey</code> 来进行解包(而系统默认的 <code>key</code> 是 <code>root</code>, Apple 我不是很懂你啊😂), 但之前版本需要使用 <code>+[NSPropertyListSerialization propertyListWithData:roptions:format:error:]</code> 进行解包, 封包时也要注意区分.<br>　　在 iOS 8 中, 因为 <code>NSURLSessionResumeInfoVersion</code> 版本过旧, 新版本的 <code>NSURLSessionResumeInfoTempFileName</code> 会被 <code>NSURLSessionResumeInfoLocalPath</code> 代替, 缓存文件路径将不再只是文件名, 而是文件路径, 需要注意, 但影响不大, 运行并无问题.<br>　　<img src="https://user-gold-cdn.xitu.io/2018/11/23/1673fc0c1f0fd8a5?w=300&amp;h=168&amp;f=gif&amp;s=1899300" alt="Apple 就是可以为所欲为"></li></ul><p>　　</p><ul><li><p>文件校验<br>　　在下载一些大文件时, 为了保证文件完整性而需要进行文件校验, <code>FKDownloader</code> 可配置是否开启文件校验.<br>　　其中, 使用 <code>NSDataReadingMappedIfSafe</code> 选项进行初始化 <code>NSData</code>, 以防止超大文件导致内存溢出.<br>　　经过测试, 6G 大小的文件算出 MD5 需要 4~5秒, 内存占用 &lt; 1M, 但因为 Hash 操作为计算密集型, 导致 CPU 占用 &gt; 90%, 所以一般情况下, 下载小型文件时可开启文件校验, 但超大文件请酌情处理.</p></li><li><p>NSURLSessionDownloadTask<br>　　在调用 <code>-[NSURLSessionDownloadTask cancelByProducingResumeData:]</code> 后, 虽然任务状态改变为 <code>NSURLSessionTaskStateCanceling</code>, 但在之后代理 <code>-[URLSession URLSession:task:didCompleteWithError:]</code> 中获取, 状态为 <code>NSURLSessionTaskStateCompleted</code>, 差点被坑的不轻, 所以目前状态管理完全由 <code>FKTask</code> 的 <code>status</code> 属性代劳.</p></li><li><p>网络可达性 Network Reachability<br>　　使用 <a href="https://developer.apple.com/library/archive/samplecode/Reachability/Introduction/Intro.html" target="_blank" rel="noopener">官方文件</a> 处理网络状态的检测与监听, 但官方的方式只适合真机运行, 在虚拟机中只可监听到失去网络的状态, 而再次连接网络的状态无法获取, 但在真机中所有状态都可监听, 所以测试网络状态时请使用真机测试.</p></li></ul><h4 id="FKDownloader-最佳实践"><a href="#FKDownloader-最佳实践" class="headerlink" title="FKDownloader 最佳实践"></a>FKDownloader 最佳实践</h4><p>请查看运行 <a href="https://github.com/SYFH/FKDownloader" target="_blank" rel="noopener">Demo</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;接触-BUG&quot;&gt;&lt;a href=&quot;#接触-BUG&quot; class=&quot;headerlink&quot; title=&quot;接触 BUG&quot;&gt;&lt;/a&gt;接触 BUG&lt;/h4&gt;&lt;p&gt;　　前几天突然收到一朋友发来的消息, 说是在 iOS 12 上遇到了一个新的 BUG, 问我怎么看? 我说新系统遇到 BUG 不是很正常吗? 大概是个什么情况?&lt;br&gt;　　经过朋友说明, 大概是这么个现象: 他用了一个第三方下载管理器进行视频下载, 明明是设置了后台下载的, 但 App 一推到后台再回到前台, 下载进度就不动了, 但任务依然还在继续下载. 系统是 iOS 12, 手机是 iPhone 7.&lt;br&gt;　　&lt;br&gt;
    
    </summary>
    
      <category term="开发学习" scheme="http://norld.com/categories/%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="iOS" scheme="http://norld.com/tags/iOS/"/>
    
      <category term="后台下载" scheme="http://norld.com/tags/%E5%90%8E%E5%8F%B0%E4%B8%8B%E8%BD%BD/"/>
    
      <category term="FKDownloader" scheme="http://norld.com/tags/FKDownloader/"/>
    
      <category term="NSURLSession" scheme="http://norld.com/tags/NSURLSession/"/>
    
      <category term="NSURLSessionDownloadTask" scheme="http://norld.com/tags/NSURLSessionDownloadTask/"/>
    
      <category term="第三方库" scheme="http://norld.com/tags/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
      <category term="iOS BUG" scheme="http://norld.com/tags/iOS-BUG/"/>
    
  </entry>
  
  <entry>
    <title>获取 XCAsset 中 mp4, mp3 等非图片资源</title>
    <link href="http://norld.com/2017/12/22/%E8%8E%B7%E5%8F%96%20XCAsset%20%E4%B8%AD%20mp4,%20mp3%20%E7%AD%89%E9%9D%9E%E5%9B%BE%E7%89%87%E8%B5%84%E6%BA%90/"/>
    <id>http://norld.com/2017/12/22/获取 XCAsset 中 mp4, mp3 等非图片资源/</id>
    <published>2017-12-22T07:38:50.000Z</published>
    <updated>2017-12-22T07:47:46.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>在 <code>xcasset</code> 添加 <code>Data Set</code> 内容, 如 <code>.mp3</code>, <code>.mp4</code> 等非图片内容时, 通过 <code>NSBundle</code> 无法获取文件路径, <code>-[NSBundle pathForResource:ofType:]</code> 方法返回为 <code>nil</code>.</p><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>不改变文件存放位置的前提下, 获取文件的路径或二进制内容.</p><a id="more"></a><h3 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h3><p><code>Assets.xcassets</code> 内选择 <code>+</code> -&gt; 选择 <code>New Data Set</code>, 将 <code>demo.mp4</code> 添加到指定位置, Set 的名字重名为 <code>test</code>.</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>通过 <code>NSDataAsset</code> 类来获取 <code>xcasset</code> 文件夹内的文件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// xcasset 内包含 test.mp4 Data Set</span><br><span class="line">NSString *fileName = @&quot;test&quot;;</span><br><span class="line">NSDataAsset *dataAsset = [[NSDataAsset alloc] initWithName:fileName];</span><br><span class="line">[dataAsset.data writeToFile:/* save file path */ atomically:YES]</span><br><span class="line">NSURL *filePath = [NSURL fileURLWithPath:/* save file path */];</span><br></pre></td></tr></table></figure><p>至此, 就可以获取 <code>xcasset</code> 中非图片资源了</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p><code>NSDataAsset</code> 为 <font color="red"><strong>iOS 9.0 及以上</strong></font> 才可使用的方法</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul><li><a href="https://developer.apple.com/documentation/uikit/nsdataasset?language=objc" target="_blank" rel="noopener">NSDataAsset</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;场景&quot;&gt;&lt;a href=&quot;#场景&quot; class=&quot;headerlink&quot; title=&quot;场景&quot;&gt;&lt;/a&gt;场景&lt;/h3&gt;&lt;p&gt;在 &lt;code&gt;xcasset&lt;/code&gt; 添加 &lt;code&gt;Data Set&lt;/code&gt; 内容, 如 &lt;code&gt;.mp3&lt;/code&gt;, &lt;code&gt;.mp4&lt;/code&gt; 等非图片内容时, 通过 &lt;code&gt;NSBundle&lt;/code&gt; 无法获取文件路径, &lt;code&gt;-[NSBundle pathForResource:ofType:]&lt;/code&gt; 方法返回为 &lt;code&gt;nil&lt;/code&gt;.&lt;/p&gt;&lt;h3 id=&quot;目标&quot;&gt;&lt;a href=&quot;#目标&quot; class=&quot;headerlink&quot; title=&quot;目标&quot;&gt;&lt;/a&gt;目标&lt;/h3&gt;&lt;p&gt;不改变文件存放位置的前提下, 获取文件的路径或二进制内容.&lt;/p&gt;
    
    </summary>
    
      <category term="开发学习" scheme="http://norld.com/categories/%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="iOS" scheme="http://norld.com/tags/iOS/"/>
    
      <category term="XCAsset" scheme="http://norld.com/tags/XCAsset/"/>
    
      <category term="日积月累" scheme="http://norld.com/tags/%E6%97%A5%E7%A7%AF%E6%9C%88%E7%B4%AF/"/>
    
      <category term="编程技巧" scheme="http://norld.com/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>Core Foundation 学习 -- 图片质量的压缩与转换</title>
    <link href="http://norld.com/2017/03/21/Core%20Foundation%20%E5%AD%A6%E4%B9%A0%20--%20%E5%9B%BE%E7%89%87%E8%B4%A8%E9%87%8F%E7%9A%84%E5%8E%8B%E7%BC%A9%E4%B8%8E%E8%BD%AC%E6%8D%A2/"/>
    <id>http://norld.com/2017/03/21/Core Foundation 学习 -- 图片质量的压缩与转换/</id>
    <published>2017-03-21T10:02:00.000Z</published>
    <updated>2017-03-22T06:01:17.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>&emsp;&emsp;在 UIKit 中有两种图片质量压缩与转换的写法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UIImageJPEGRepresentation(image, 0.75);</span><br><span class="line">UIImagePNGRepresentation(image);</span><br></pre></td></tr></table></figure><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>&emsp;&emsp;用 <code>Core Foundation</code> 实现相同功能</p><a id="more"></a><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ul><li>创建 <code>Translate</code> 类的相关文件<ul><li>包含 <code>Translate.h</code> 和 <code>Translate.m</code> 文件</li><li>删除所有 <code>@interface</code> 和 <code>@implementation</code> 相关的内容<ul><li>这一步可不做, 之后的内容并没有操作 <code>Translate</code> 的类或实例对象</li></ul></li></ul></li><li><p>在 <code>Translate.h</code> 中</p><ul><li><p>创建结果相关的 Blok</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef void(^complet)(BOOL isSuccess);</span><br></pre></td></tr></table></figure></li><li><p>创建格式转换相关的枚举</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSUInteger, kUTType) &#123;</span><br><span class="line">    kUTTypeJPEG,</span><br><span class="line">    kUTTypePNG</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>声明定义压缩转换方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extern void TImageRepresentation(NSString *sourceImagePath,NSString *targetImagePatch,double compressionQuality,kUTType type,complet complet);</span><br></pre></td></tr></table></figure></li></ul></li></ul><blockquote><table><thead><tr><th>参数</th><th>格式</th><th>定义</th></tr></thead><tbody><tr><td>sourceImagePath</td><td><code>NSString *</code></td><td>原图片文件路径</td></tr><tr><td>targetImagePatch</td><td><code>NSString *</code></td><td>输出路径, 必须包含文件名与后缀</td></tr><tr><td>compressionQuality</td><td><code>double</code></td><td>图片压缩质量, 范围 0~1, 1为最高质量</td></tr><tr><td>type</td><td><code>kUTType</code></td><td>输出格式, 务必与输出路径的后缀相同</td></tr><tr><td>complet</td><td><code>Block</code></td><td>输出结果的回调</td></tr></tbody></table></blockquote><ul><li><p>在 <code>Translate.m</code> 中</p><ul><li><p>引入相关头文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;ImageIO/ImageIO.h&gt;</span><br><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br></pre></td></tr></table></figure></li><li><p>开始实现压缩转换方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void TImageRepresentation(NSString *sourceImagePath,</span><br><span class="line">                          NSString *targetImagePatch,</span><br><span class="line">                          double compressionQuality,</span><br><span class="line">                          kUTType type,</span><br><span class="line">                          complet complet) &#123;</span><br><span class="line">    // do something...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>开启子线程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">    // do something...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获取图片源数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CGImageRef image = [UIImage imageWithContentsOfFile:sourceImagePath].CGImage;</span><br></pre></td></tr></table></figure></li><li><p>创建接收最终数据的目标容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CFMutableDataRef imageData = CFDataCreateMutable(NULL, 0);</span><br></pre></td></tr></table></figure></li><li><p>判断转换格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CFStringRef typeStr;</span><br><span class="line">switch (type) &#123;</span><br><span class="line">    case kUTTypeJPEG:</span><br><span class="line">        typeStr = CFSTR(&quot;public.jpeg&quot;);</span><br><span class="line">        break;</span><br><span class="line">            </span><br><span class="line">    case kUTTypePNG:</span><br><span class="line">        typeStr = CFSTR(&quot;public.png&quot;);</span><br><span class="line">        break;</span><br><span class="line">            </span><br><span class="line">    default:</span><br><span class="line">        break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建转换者对象, 进行质量压缩和转换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CGImageDestinationRef destination = CGImageDestinationCreateWithData(imageData, typeStr, 1, NULL);</span><br></pre></td></tr></table></figure><p><code>CGImageDestinationCreateWithData(_,_,_,_)</code> 函数的<a href="https://developer.apple.com/reference/imageio/1465133-cgimagedestinationcreatewithdata?language=objc" target="_blank" rel="noopener">相关详情</a></p></li><li><p>创建所需参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSDictionary *properties = @&#123; (__bridge id)kCGImagePropertyMakerNikonQuality : @(compressionQuality) &#125;;</span><br></pre></td></tr></table></figure></li><li><p>向转换者对象添加图片数据和参数数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CGImageDestinationAddImage(destination, image, (__bridge CFDictionaryRef)properties);</span><br></pre></td></tr></table></figure><p><code>CGImageDestinationAddImage(_,_,_)</code> 函数的<a href="https://developer.apple.com/reference/imageio/1464962-cgimagedestinationaddimage?language=objc" target="_blank" rel="noopener">相关详情</a></p></li><li><p>检测转换是否成功, 如失败直接释放数据源与转换者对象, 并结束所有流程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if (!CGImageDestinationFinalize(destination)) &#123;</span><br><span class="line">    CFRelease(imageData);</span><br><span class="line">    imageData = NULL;</span><br><span class="line">    if (complet) &#123;</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            complet(NO);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    // 释放转换者对象</span><br><span class="line">    CFRelease(destination);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>成功后释放转换者对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CFRelease(destination);</span><br></pre></td></tr></table></figure></li><li><p>根据输出地址, 创建输出流</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CFAllocatorRef allocator = CFAllocatorGetDefault();</span><br><span class="line">NSURL *fileUrl = [NSURL fileURLWithPath:targetImagePatch];</span><br><span class="line">CFWriteStreamRef writeStream = CFWriteStreamCreateWithFile(allocator, (__bridge CFURLRef)fileUrl);</span><br></pre></td></tr></table></figure></li><li><p>开启输出流</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CFWriteStreamOpen(writeStream);</span><br></pre></td></tr></table></figure></li><li><p>向目标容器写入最终数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CFIndex result = CFWriteStreamWrite(writeStream, CFDataGetBytePtr(imageData), CFDataGetLength(imageData));</span><br></pre></td></tr></table></figure><p><code>CFWriteStreamWrite(_,_,_)</code> 函数的<a href="https://developer.apple.com/reference/corefoundation/1539680-cfwritestreamwrite?language=objc" target="_blank" rel="noopener">相关详情</a></p></li><li><p>判断最终数据写入是否成功</p><p>&emsp;&emsp;不成功的返回值为 -1, 成功则为输出的字节流长度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">if (result != -1) &#123;</span><br><span class="line">    if (complet) &#123;</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            complet(YES);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    if (complet) &#123;</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            complet(NO);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>关闭输出流</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CFWriteStreamClose(writeStream);</span><br></pre></td></tr></table></figure></li><li><p>释放目标容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CFRelease(imageData);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>&emsp;&emsp;简单使用:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">NSString *sourceImagePath = @&quot;要进行处理的图片的路径&quot;;</span><br><span class="line">NSString *targetImagePath = @&quot;处理完成的输出路径&quot;;</span><br><span class="line">double compressionQuality = 0.75f;</span><br><span class="line">kUTType targetImageType = kUTTypeJPEG;</span><br><span class="line">    </span><br><span class="line">TImageRepresentation(sourceImagePath, targetImagePath, compressionQuality, targetImageType, ^(BOOL isSuccess) &#123;</span><br><span class="line">    if (isSuccess) &#123;</span><br><span class="line">        NSLog(@&quot;Winer&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        NSLog(@&quot;Loser&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h3><ul><li><p><a href="https://developer.apple.com/reference/imageio/cgimagedestination?language=objc" target="_blank" rel="noopener">Apple 文档 - CGImage​Destination</a></p></li><li><p><a href="https://developer.apple.com/reference/corefoundation/cfwritestream?language=objc" target="_blank" rel="noopener">Apple 文档 - CFWrite​Stream</a></p></li><li><p><a href="https://developer.apple.com/reference/mobilecoreservices/uttype?language=objc" target="_blank" rel="noopener">Apple 文档 - UTType</a></p></li><li><p><a href="https://developer.apple.com/library/content/documentation/FileManagement/Conceptual/understanding_utis/understand_utis_conc/understand_utis_conc.html#//apple_ref/doc/uid/TP40001319-CH202-BCGJGJGA" target="_blank" rel="noopener">Apple 文档 - 统一类型标识符 UTI</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;开始&quot;&gt;&lt;a href=&quot;#开始&quot; class=&quot;headerlink&quot; title=&quot;开始&quot;&gt;&lt;/a&gt;开始&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;在 UIKit 中有两种图片质量压缩与转换的写法:&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;UIImageJPEGRepresentation(image, 0.75);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;UIImagePNGRepresentation(image);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h3 id=&quot;目标&quot;&gt;&lt;a href=&quot;#目标&quot; class=&quot;headerlink&quot; title=&quot;目标&quot;&gt;&lt;/a&gt;目标&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;用 &lt;code&gt;Core Foundation&lt;/code&gt; 实现相同功能&lt;/p&gt;
    
    </summary>
    
      <category term="开发学习" scheme="http://norld.com/categories/%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="iOS" scheme="http://norld.com/tags/iOS/"/>
    
      <category term="Core Foundation" scheme="http://norld.com/tags/Core-Foundation/"/>
    
      <category term="Image I/O" scheme="http://norld.com/tags/Image-I-O/"/>
    
      <category term="仿制系统系列" scheme="http://norld.com/tags/%E4%BB%BF%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%B3%BB%E5%88%97/"/>
    
      <category term="图片质量压缩" scheme="http://norld.com/tags/%E5%9B%BE%E7%89%87%E8%B4%A8%E9%87%8F%E5%8E%8B%E7%BC%A9/"/>
    
      <category term="图片转换" scheme="http://norld.com/tags/%E5%9B%BE%E7%89%87%E8%BD%AC%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>深入理解 [super init]</title>
    <link href="http://norld.com/2017/03/15/%E6%B7%B1%E5%BA%A6%E7%90%86%E8%A7%A3%20super%20init/"/>
    <id>http://norld.com/2017/03/15/深度理解 super init/</id>
    <published>2017-03-15T07:02:00.000Z</published>
    <updated>2017-03-16T08:37:55.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>&emsp;&emsp;创建一个 <code>Test</code> 测试类, 重写初始化方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)init &#123;</span><br><span class="line">   self = [super init];</span><br><span class="line">   if (self) &#123;</span><br><span class="line">       // do something...</span><br><span class="line">   &#125;</span><br><span class="line">   return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="疑问"><a href="#疑问" class="headerlink" title="疑问:"></a>疑问:</h3><ul><li>为何要执行 <code>[super init]</code> ?</li><li><code>[super init]</code> 的结果为何要 <code>self</code> 接收?</li></ul><a id="more"></a><h3 id="探索"><a href="#探索" class="headerlink" title="探索:"></a>探索:</h3><ul><li><code>[super init]</code></li></ul><p>&emsp;&emsp;这一句看起来很有迷惑性, 一个 <code>super</code> 关键字, 好像初始化的是父类, 但在码代码的时候可以注意一个细节: 在写 <code>self</code> 时, 代码提示是有返回值类型的, 而写 <code>[super init]</code> 时, 并没有返回值类型, 但在别处写 <code>super</code> 时, 自动提示的返回值类型是父类.</p><p>&emsp;&emsp;这表示在 <code>[super init]</code> 这句话中, <code>super</code> 并不是指父类, 可能只是一个没有什么卵用的关键字, 但在苹果的官方文档中, 这么写是推荐的写法, 那么这句话就很关键了.</p><p>&emsp;&emsp;通过 <code>clang -rewrite-objc Test.m</code> 命令, 重新编译成 cpp 文件, 可以看到这一行代码究竟做了什么:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static instancetype _I_Test_init(Test * self, SEL _cmd) &#123;</span><br><span class="line">    self = ((Test *(*)(__rw_objc_super *, SEL))(void *)objc_msgSendSuper)((__rw_objc_super)&#123;(id)self, (id)class_getSuperclass(objc_getClass(&quot;Test&quot;))&#125;, sel_registerName(&quot;init&quot;));</span><br><span class="line">    if (self) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;经过简化后, <code>[super init]</code> 就变为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_msgSendSuper(&#123;self, class_getSuperclass(objc_getClass(&quot;Test&quot;))&#125;, sel_registerName(&quot;init&quot;));</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;而其中 <code>objc_msgSendSuper()</code> 这个方法, API 文档是这样描述的:</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OBJC_EXPORT void objc_msgSendSuper(void /* struct objc_super *super, SEL op, ... */ )  OBJC_AVAILABLE(10.0, 2.0, 9.0, 1.0);</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>Sends a message with a simple return value to the superclass of an instance of a class.<br>将具有返回值的消息发送到一个实例的超类.</p></blockquote><p>&emsp;&emsp;第一个参数是 <code>objc_suoer</code> 类型的结构体, 第二个或更多是 <code>SEL</code> 方法选择器, 而在 <code>runtime.m</code> 文档中, <code>objc_super</code> 的结构为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct objc_super &#123;</span><br><span class="line">    __unsafe_unretained id receiver;</span><br><span class="line">    __unsafe_unretained Class super_class;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<code>receiver</code> 是实例对象, <code>super_class</code> 是用来接收消息的类, 为实例对象的父类.</p><p>&emsp;&emsp;在当前的代码里, <code>receiver</code> 为 <code>self</code> , <code>super_class</code> 为 <code>NSObject</code> .</p><p>&emsp;&emsp;再回过头来, 注意看 <code>[super init]</code> 的 c++ 源码, 返回值为 <code>Test *</code>, 所以在这里的 <code>init</code> 只是向上初始化父类而已.</p><p>&emsp;&emsp;那么这就明了了, <code>[super init]</code> 只是为了将父类, 父类的父类, 父类的父类的父类等等等等, 从 <code>NSObject</code> 开始的所有类都初始化了一遍, 只是为了确保父类的方法, 属性都能正确使用而已.</p><ul><li><code>self = [super init]</code></li></ul><p>&emsp;&emsp;既然明白了 <code>[super init]</code> 做了什么, 那么返回结果再赋值给 <code>self</code> 就基本没有疑问了: 如果在 <code>[super init]</code> 这一步因为一些不明的原因导致初始化失败, 那么返回值应该是为 <code>nil</code> 的, 这时候让 <code>self</code> 接收一下, 之后用 <code>if</code> 判断, 则可以避免一些 BUG.</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>为何要执行 <code>[super init]</code> ?<ul><li>为了将当前实例的父类树进行初始化, 以保证继承父类树的所有属性与方法.</li></ul></li><li><code>[super init]</code> 的结果为何要 <code>self</code> 接收?<ul><li>为了确保初始化不会因为失败而 crash.</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;开始&quot;&gt;&lt;a href=&quot;#开始&quot; class=&quot;headerlink&quot; title=&quot;开始&quot;&gt;&lt;/a&gt;开始&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;创建一个 &lt;code&gt;Test&lt;/code&gt; 测试类, 重写初始化方法:&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (instancetype)init &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   self = [super init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   if (self) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       // do something...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   return self;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h3 id=&quot;疑问&quot;&gt;&lt;a href=&quot;#疑问&quot; class=&quot;headerlink&quot; title=&quot;疑问:&quot;&gt;&lt;/a&gt;疑问:&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;为何要执行 &lt;code&gt;[super init]&lt;/code&gt; ?&lt;/li&gt;&lt;li&gt;&lt;code&gt;[super init]&lt;/code&gt; 的结果为何要 &lt;code&gt;self&lt;/code&gt; 接收?&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="开发学习" scheme="http://norld.com/categories/%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="iOS" scheme="http://norld.com/tags/iOS/"/>
    
      <category term="Runtime" scheme="http://norld.com/tags/Runtime/"/>
    
      <category term="深入理解" scheme="http://norld.com/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>HelloWorld</title>
    <link href="http://norld.com/2017/01/13/HelloWorld/"/>
    <id>http://norld.com/2017/01/13/HelloWorld/</id>
    <published>2017-01-13T04:33:00.000Z</published>
    <updated>2017-07-12T05:57:23.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="新的开始"><a href="#新的开始" class="headerlink" title="新的开始"></a>新的开始</h3><p>hello world!<br><a id="more"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;Foundation/Foundation.h&quot;</span><br><span class="line"></span><br><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    NSLog(@&quot;Hello world!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;新的开始&quot;&gt;&lt;a href=&quot;#新的开始&quot; class=&quot;headerlink&quot; title=&quot;新的开始&quot;&gt;&lt;/a&gt;新的开始&lt;/h3&gt;&lt;p&gt;hello world!&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
