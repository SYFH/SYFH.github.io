<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Norld&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://norld.com/"/>
  <updated>2019-04-28T15:23:49.995Z</updated>
  <id>http://norld.com/</id>
  
  <author>
    <name>Norld</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>搭建 Docker + Flask 后端</title>
    <link href="http://norld.com/2018/12/26/DockerFlaskApi/"/>
    <id>http://norld.com/2018/12/26/DockerFlaskApi/</id>
    <published>2018-12-26T07:38:50.000Z</published>
    <updated>2019-04-28T15:23:49.995Z</updated>
    
    <content type="html"><![CDATA[<h1 id="搭建-Docker-Flask-后端"><a href="#搭建-Docker-Flask-后端" class="headerlink" title="搭建 Docker + Flask 后端"></a>搭建 Docker + Flask 后端</h1><p>使用 Docker + Flask + Gunicorn + Gevent + nginx 来搭建纯 API 后端</p><h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>使用 Docker 编排管理服务, 使用 Shell 脚本一键化部署流程</p><a id="more"></a><h1 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h1><p>创建目录/文件, 结构如下:</p><p>site<br>|– flask<br>&nbsp;&nbsp;&nbsp;&nbsp;|– Dockerfile<br>&nbsp;&nbsp;&nbsp;&nbsp;|– server<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|– config<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|– gunicorn.conf.py<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|– app.py<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|– requirements.txt<br>|– nginx<br>&nbsp;&nbsp;&nbsp;&nbsp;|– default.conf<br>|– docker-compose.yml<br>|– deploy.sh</p><h1 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h1><h4 id="flask-Dockerfile"><a href="#flask-Dockerfile" class="headerlink" title="flask/Dockerfile"></a>flask/Dockerfile</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">FROM python:3.7</span><br><span class="line"></span><br><span class="line">COPY ./server /workspace</span><br><span class="line">WORKDIR /workspace</span><br><span class="line"></span><br><span class="line">RUN pip install -i https://mirrors.aliyun.com/pypi/simple/ --upgrade pip \</span><br><span class="line">&amp;&amp; pip --no-cache-dir install -i https://mirrors.aliyun.com/pypi/simple/ -r requirements.txt</span><br><span class="line"></span><br><span class="line">EXPOSE 5000</span><br><span class="line"></span><br><span class="line">CMD [&quot;gunicorn&quot;, &quot;app:app&quot;, &quot;-c&quot;, &quot;./config/gunicorn.conf.py&quot;]</span><br></pre></td></tr></table></figure><h4 id="flask-server-requirements-txt"><a href="#flask-server-requirements-txt" class="headerlink" title="flask/server/requirements.txt"></a>flask/server/requirements.txt</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Flask==1.0.2</span><br><span class="line">gunicorn==19.9.0</span><br><span class="line">gevent==1.4.0</span><br></pre></td></tr></table></figure><h4 id="flask-server-app-py"><a href="#flask-server-app-py" class="headerlink" title="flask/server/app.py"></a>flask/server/app.py</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from flask import Flask</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">@app.route(&apos;/&apos;)</span><br><span class="line">def hello_world():</span><br><span class="line">    return &apos;Hello, World!&apos;</span><br></pre></td></tr></table></figure><h4 id="flask-server-config-gunicorn-conf-py"><a href="#flask-server-config-gunicorn-conf-py" class="headerlink" title="flask/server/config/gunicorn.conf.py"></a>flask/server/config/gunicorn.conf.py</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">workers = 5</span><br><span class="line">worker_class = &quot;gevent&quot;</span><br><span class="line">bind = &quot;0.0.0.0:5000&quot;</span><br><span class="line">loglevel = &apos;debug&apos;</span><br></pre></td></tr></table></figure><h4 id="nginx-default-conf"><a href="#nginx-default-conf" class="headerlink" title="nginx/default.conf"></a>nginx/default.conf</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name api.site.com;</span><br><span class="line">    listen [::]:80;</span><br><span class="line">    server_tokens off;</span><br><span class="line">    client_max_body_size 15M;</span><br><span class="line"></span><br><span class="line">    access_log  /var/log/nginx/nginx.api.access.log;</span><br><span class="line">    error_log   /var/log/nginx/nginx.api.error.log;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_set_header Host $http_host;</span><br><span class="line">        proxy_set_header X-NginX-Proxy true;</span><br><span class="line"></span><br><span class="line">        proxy_pass http://flask:5000;</span><br><span class="line">        proxy_redirect off;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="docker-compose-yml"><a href="#docker-compose-yml" class="headerlink" title="docker-compose.yml"></a>docker-compose.yml</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line">services:</span><br><span class="line">  nginx:</span><br><span class="line">    image: nginx:alpine</span><br><span class="line">    volumes:</span><br><span class="line">      - ./nginx:/etc/nginx/conf.d</span><br><span class="line">      - /var/log/nginx:/var/log/nginx</span><br><span class="line">    links:</span><br><span class="line">      - flask</span><br><span class="line">    ports:</span><br><span class="line">      - 80:80</span><br><span class="line">  flask:</span><br><span class="line">    build:</span><br><span class="line">      context: ./flask</span><br></pre></td></tr></table></figure><h4 id="deploy-sh"><a href="#deploy-sh" class="headerlink" title="deploy.sh"></a>deploy.sh</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">rm -rf &apos;tmp.tar&apos;</span><br><span class="line">cd &apos;..&apos;</span><br><span class="line">tar cf &apos;tmp.tar&apos; &apos;site&apos;</span><br><span class="line">mv &apos;tmp.tar&apos; &apos;site/tmp.tar&apos;</span><br><span class="line">cd &apos;site&apos;</span><br><span class="line"></span><br><span class="line">sftp &apos;root@api.norld.com&apos; &lt;&lt;EOF</span><br><span class="line">cd &apos;/root&apos;</span><br><span class="line">put &apos;tmp.tar&apos;</span><br><span class="line">exit</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">rm -rf &apos;tmp.tar&apos;</span><br><span class="line"></span><br><span class="line">ssh &apos;user@api.site.com&apos; &lt;&lt;EOF</span><br><span class="line">rm -rf &apos;site&apos;</span><br><span class="line">tar xf &apos;tmp.tar&apos;</span><br><span class="line">cd &apos;site&apos;</span><br><span class="line">docker-compose down</span><br><span class="line">docker-compose up --build -d</span><br><span class="line">echo &apos;y&apos; | docker image prune</span><br><span class="line">exit</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h1 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h1><p>将部分参数替换成你需要的, 终端执行 deploy.sh, 开始访问 <a href="http://api.site.com" target="_blank" rel="noopener">http://api.site.com</a>, Hello, World!</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;搭建-Docker-Flask-后端&quot;&gt;&lt;a href=&quot;#搭建-Docker-Flask-后端&quot; class=&quot;headerlink&quot; title=&quot;搭建 Docker + Flask 后端&quot;&gt;&lt;/a&gt;搭建 Docker + Flask 后端&lt;/h1&gt;&lt;p&gt;使用 Docker + Flask + Gunicorn + Gevent + nginx 来搭建纯 API 后端&lt;/p&gt;&lt;h1 id=&quot;目标&quot;&gt;&lt;a href=&quot;#目标&quot; class=&quot;headerlink&quot; title=&quot;目标&quot;&gt;&lt;/a&gt;目标&lt;/h1&gt;&lt;p&gt;使用 Docker 编排管理服务, 使用 Shell 脚本一键化部署流程&lt;/p&gt;
    
    </summary>
    
      <category term="开发学习" scheme="http://norld.com/categories/%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Server" scheme="http://norld.com/tags/Server/"/>
    
      <category term="Docker" scheme="http://norld.com/tags/Docker/"/>
    
      <category term="Flask" scheme="http://norld.com/tags/Flask/"/>
    
      <category term="Gunicorn" scheme="http://norld.com/tags/Gunicorn/"/>
    
      <category term="Gevent" scheme="http://norld.com/tags/Gevent/"/>
    
      <category term="nginx" scheme="http://norld.com/tags/nginx/"/>
    
      <category term="后端" scheme="http://norld.com/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>解决 xcode 10 移除 libstdc++ 导致的 file not found 错误</title>
    <link href="http://norld.com/2018/12/26/xcode-10-libstdc++/"/>
    <id>http://norld.com/2018/12/26/xcode-10-libstdc++/</id>
    <published>2018-12-26T07:38:50.000Z</published>
    <updated>2019-04-08T01:27:15.995Z</updated>
    
    <content type="html"><![CDATA[<h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><p>　　解决 xcode 10 移除 libstdc++ 库, 替换为 libc++ 库而导致无法找到头文件的问题.</p><a id="more"></a><h4 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h4><ol><li><p>准备数据, 拉取 <a href="https://github.com/SYFH/Xcode_libstdc.git" target="_blank" rel="noopener">Xcode_libstdc</a> 到本地.</p></li><li><p>进入项目根目录, 执行 copy.sh 脚本, 参数必须填入当前 xcode.app 的路径.<br><img src="https://upload-images.jianshu.io/upload_images/3269191-9cd1bcf23bfbe4b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="copy.png"></p></li></ol><ol start="3"><li><p><font color="red"><strong>[此步骤必须执行]</strong></font> 打开需要 libstdc++ 的项目, 选择 Xcode -&gt; File -&gt; Workspace Setting… -&gt; Build System, 选择 Legacy Build System, 重新编译.</p></li><li><p>完成!</p></li></ol><h4 id="参考"><a href="#参考" class="headerlink" title="参考:"></a>参考:</h4><ol><li><a href="https://stackoverflow.com/a/53644801" target="_blank" rel="noopener">stackoverflow ld: library not found for -lstdc++.6</a></li><li><a href="https://stackoverflow.com/a/52757858" target="_blank" rel="noopener">stackoverflow Xcode 10 (iOS 12) does not contain libstdc++6.0.9</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;目标&quot;&gt;&lt;a href=&quot;#目标&quot; class=&quot;headerlink&quot; title=&quot;目标&quot;&gt;&lt;/a&gt;目标&lt;/h4&gt;&lt;p&gt;　　解决 xcode 10 移除 libstdc++ 库, 替换为 libc++ 库而导致无法找到头文件的问题.&lt;/p&gt;
    
    </summary>
    
      <category term="开发学习" scheme="http://norld.com/categories/%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="iOS" scheme="http://norld.com/tags/iOS/"/>
    
      <category term="xcode" scheme="http://norld.com/tags/xcode/"/>
    
      <category term="libstdc++" scheme="http://norld.com/tags/libstdc/"/>
    
      <category term="libc++" scheme="http://norld.com/tags/libc/"/>
    
  </entry>
  
  <entry>
    <title>一个系统BUG引发的血案 -- FKDownloader</title>
    <link href="http://norld.com/2018/11/29/FKDownloader/"/>
    <id>http://norld.com/2018/11/29/FKDownloader/</id>
    <published>2018-11-29T13:52:30.000Z</published>
    <updated>2018-11-29T13:54:46.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="接触-BUG"><a href="#接触-BUG" class="headerlink" title="接触 BUG"></a>接触 BUG</h4><p>　　前几天突然收到一朋友发来的消息, 说是在 iOS 12 上遇到了一个新的 BUG, 问我怎么看? 我说新系统遇到 BUG 不是很正常吗? 大概是个什么情况?<br>　　经过朋友说明, 大概是这么个现象: 他用了一个第三方下载管理器进行视频下载, 明明是设置了后台下载的, 但 App 一推到后台再回到前台, 下载进度就不动了, 但任务依然还在继续下载. 系统是 iOS 12, 手机是 iPhone 7.<br>　　<br>　　<a id="more"></a></p><h4 id="BUG-详情"><a href="#BUG-详情" class="headerlink" title="BUG 详情"></a>BUG 详情</h4><p>　　刚一开始还以为第三方在进度处理方面写的有问题, 但我把这个第三方的 <a href="https://github.com/XXDownload/XXDownload" target="_blank" rel="noopener">Demo</a> 下载运行后, 发现这根本不是第三方问题, 而是系统问题, 系统代理 <code>-[NSURLSessionDownloadTask URLSession:downloadTask:didWriteData:totalBytesWritten:totalBytesExpectedToWrite:]</code> 根本没有被调用, 所以下载进度根本就无法继续计算.<br>　　然后我改为使用 KVO 监听 <code>NSURLSessionDownloadTask</code> 的 <code>countOfBytesReceived</code> 和 <code>countOfBytesExpectedToReceive</code> 属性来计算当前下载进度, 但很遗憾, 这两个值在重回前台后就没在继续变化, 初步认定是系统在处理数据接收时出现了异常, 导致省略了值的改变, 还有顺便躺枪的进度代理.<br>　　上一次遇到这种系统犯法失效的 BUG 还是在 iOS 11.1/11.2 上, 当时开发录屏直播, 系统方法 <code>-[RPBroadcastSampleHandler processSampleBuffer:withType:]</code> 没有被调用, 直接坑掉了一个大功能模块, 但幸好, 这一回遇到的 BUG 不算严重, 解决方法还是有的.</p><h4 id="开始测试"><a href="#开始测试" class="headerlink" title="开始测试"></a>开始测试</h4><p>　　这回的进度 BUG 在虚拟机上是不会出现的, 必须真机, 而且经过测试, 发现只在 iOS 12/12.1, iPhone 8 以下才会出现.<br>　　在测试时还发现 App 完全退出后, 后台下载任务会直接取消, 但是带有恢复数据.<br>　　进入前台后, 手动进行 <code>暂停-&gt;继续</code> 操作后, 代理/KVO 就会继续工作.</p><h4 id="尝试修复-BUG"><a href="#尝试修复-BUG" class="headerlink" title="尝试修复 BUG"></a>尝试修复 BUG</h4><p>　　既然手动 <code>暂停-&gt;继续</code> 可以修复 BUG, 那只要用代码重现一遍就可以了吧? 别急, 事情没有那么简单.<br>　　直接在 <code>-[AppDelegate applicationWillEnterForeground:]</code> 开始遍历所有下载任务, 都执行一遍 <code>暂停-&gt;继续</code> 操作, 这个方法很简单, 很粗暴, 但, 这不管用!<br>　　那么使用 <code>-[NSURLSessionDownloadTask cancelByProducingResumeData:]</code> -&gt; <code>-[NSURLSession downloadTaskWithResumeData:]</code> 代替 <code>暂停-&gt;继续</code> 呢? 不错, 意识到当前的 <code>NSURLSessionDownloadTask</code> 可能存在脏数据是个进步, 但, 这依然不管用!</p><p><img src="https://user-gold-cdn.xitu.io/2018/11/23/1673fc0c1cecf0ab?w=300&amp;h=186&amp;f=gif&amp;s=2049669" alt="系统的BUG"></p><p>　　最后的最后, 还是测试出来了, 必须在 <code>[AppDelegate applicationDidBecomeActive:]</code> 里面遍历使用 <code>取消-&gt;恢复</code> 才能成功</p><h4 id="关于下载器的轮子"><a href="#关于下载器的轮子" class="headerlink" title="关于下载器的轮子"></a>关于下载器的轮子</h4><p>　　朋友说你写一个下载第三方吧, 现在的下载器没几个好用的. 当时我还不以为然, 说是 GitHub 上那么多轮子, 不缺我这一个, 而且就算写了也不一定比热门的好, 实在不行还有 <code>AFNetworking</code> 当打底的.<br>　　我在很久以前我就打算写一个下载器, 想要重点实现单文件多线程分片下载, 当时数据流下载已经写完了, 数据拼接也基本完成了, 准备支持后台下载才发现, <code>NSURLSessionDataTask</code> 不支持后台下载!!! 好吧, Apple🐂🍺🤪<br>　　我也看了我朋友用的 <a href="https://github.com/XXDownload/XXDownload" target="_blank" rel="noopener">XXDownload</a>, 虽然 star 少了点, 但这个刚好符合需求. 虽然在实现中大范围使用下划线变量, 而且还在单例上使用代理, 感觉一口老血卡在喉咙里, 但至少改改还是能用的, 毕竟这种第三方也就是提供个框架而已.<br>　　而在 GitHub 上, 已经有一堆项目停止维护了, 还在更新的, 因为任务持久化使用了数据库, 引用了其他第三方, 可能导致库冲突, 而那些还在持续维护的纯净版又无法适应一些需求场景.<br>　　其中 <a href="https://github.com/Heikowi/HWIFileDownload" target="_blank" rel="noopener">HWIFileDownload</a> 就属于一直在更新, 也很纯净的第三方, 一般项目使用足以胜任. 但在某些特殊需求上就有点相形见绌了, 比如支持时效性下载链接, 持久化任务列表, 文件校验, 对恢复数据深度处理等.<br>　　当然, 这都不是重点, 重点是后台下载场景太稀少了, 自己随手写一个都可以勉强用, 还要什么第三方, 这种吃力不讨好, 还基本没有 Star 的操作我是不会做的.</p><p><img src="https://user-gold-cdn.xitu.io/2018/11/23/1673fc0c1cd5ac60?w=300&amp;h=184&amp;f=gif&amp;s=1019169" alt="真香"></p><h4 id="FKDownloader-–-最终还是写了"><a href="#FKDownloader-–-最终还是写了" class="headerlink" title="FKDownloader – 最终还是写了"></a>FKDownloader – 最终还是写了</h4><p>既然都写出来了, 那就必须尽量完美, 除了修复/规避 iOS 的 BUG, 当然还需要支持一些特别的需求.<br>先列一下 FKDownloader 的整体结构:</p><ul><li><p>主类</p><ul><li><p>FKDownloadManager</p><ul><li>自加载, 不必显式调用创建单例</li><li>不可继承, 唯一存在</li><li>管理 Task, 进行增删查操作</li><li>开始/暂停/恢复/取消 Task, 但实现与状态过滤全权由 Task 实现</li><li>所有任务下载进度</li><li>在 AppDelegate 处理部分功能, 如后台下载, 加载任务归档, 解决 iOS BUG 等</li></ul></li><li><p>FKConfigure</p><ul><li>统一管理特殊配置</li><li>设置 Session Identifier</li><li>设置是否为后台下载</li><li>设置是否自动清理已完成/失败任务</li><li>设置是否自动开始任务, 针对载入本地归档任务时</li><li>自定义请求超时时间</li></ul></li><li><p>FKTask</p><ul><li>开始/暂停/恢复/取消的具体实现</li><li>Block/Delegate/Notification 的发起者</li><li>校验文件</li><li>下载速度/预计剩余时间</li><li>可添加附带信息, 包括保存文件名, 校验信息, 自定义请求头等信息</li></ul></li></ul></li><li><p>辅类</p><ul><li>FKResumeHelper<ul><li>解包/封包恢复数据</li><li>修复 iOS 特定版本中错误的恢复数据</li><li>更新恢复数据的 URL</li></ul></li></ul></li><li><p>其他</p><ul><li>FKDefine: 声明枚举, C 方法, 字符串常量</li><li>FKReachability: 网络状态检测与监听</li><li>FKDownloadExecutor: 统一处理系统代理</li><li>FKTaskStorage: 管理任务的归解档</li><li>FKHashHelper: 计算 Hash</li><li>FKSystemHelper: 获取设备版本, 系统版本</li></ul></li></ul><p>FKDownloader 不依赖其他任何第三方, 保持纯净性, 其中的方法大部分都偏向于对外简单, 对内复杂, 而且尽量避免高耦合.</p><h4 id="FKDownloader-支持与安装"><a href="#FKDownloader-支持与安装" class="headerlink" title="FKDownloader 支持与安装"></a>FKDownloader 支持与安装</h4><p>必须 iOS 8 以上, 使用 ARC.<br>支持 <code>CocoaPods</code> 和 <code>Carthage</code> 安装.<br>如有其他需求, 可直接将 <code>FKDownloader</code> 文件夹直接放入项目中.</p><h4 id="FKDownloader-特点"><a href="#FKDownloader-特点" class="headerlink" title="FKDownloader 特点"></a>FKDownloader 特点</h4><ul><li>自加载<br>　　使用 <code>+[NSObject load]</code> 加载单例, 不必再显式调用来创建单例. 因此可以提前监听 <code>AppDelegate</code> 通知, 修复进度 BUG 将可以自处理, 不必显示调用.</li><li><p>重启 App 时恢复下载中任务进度<br>　　也就是开始一个后台下载任务, 完全退出 App 后再次运行 App, 需要重新拿到下载任务的进度与状态, 以达到 UI 上显示任务还在运行中的效果.<br>　　实现这个功能的第三方我只见到一两个, 这其中的重点是 <code>-[NSURLSession getTasksWithCompletionHandler:]</code> 这个系统方法, 它可以将带有 <code>identifier</code> 的 <code>NSURLSession</code> 中所有的后台任务获取到.</p></li><li><p>支持时效性 URL<br>　　获取到 FKTask 后, 可直接通过 <code>-[FKTask resumeFilePath]</code> 获取 ResumeData 保存路径, 之后用 <code>+[FKResumeHelper updateResumeData:url:]</code> 拿到更新后的 ResumeData, 再保存后即可.<br>　　也可以直接使用 <code>-[FKTask updateURL:]</code> 直接更新, 但对进行中的任务无效, 且必须已存在恢复数据.<br>　　FKDownloader 只使用 URL 的 <code>scheme://host/path</code> 创建标识符, 所以参数可以随意修改, 如果是使用请求头完成过期操作的, 可使用自定义请求头.</p></li><li><p>根据网络状态执行特定操作<br>　　检测当前网络状态, 如果没有网络则暂停进行中任务, 取消等待中任务.<br>　　当恢复网络时, 就会将因为无网络而中断的任务继续下载.</p></li><li><p>使用 <code>NSCoding</code> 持久化下载任务, 不依赖数据库<br>　　直接保存任务信息, 包括 URL, 任务状态, 保存文件名, 校验信息, 自定义请求头, 文件总大小, 已接收字节数等信息, 保证重启 App 后 UI 信息和退出 App 前保持一致.<br>　　代价就是不能高度自定义要保存的数据, 但 <code>FKTask</code> 向外暴露的属性完全满足外接式数据处理需求, 也可以使用项目中已存在的数据库进行自定义管理.</p></li><li><p>预见性处理状态/进度<br>　　设置代理时会将当前所有协议方法触发一遍, 保证 UI 获取的信息为最新.</p></li><li>任务状态/进度的监听<br>　　可以自由使用 Block/Delegate/Notification 获取, 最大化覆盖应用场景.</li><li>自定义任务附加信息<br>　　目前支持保存文件名, 文件校验值, 自定义请求头.</li><li>支持 URL 中参数可变<br>　　<code>FKTask</code> 只使用 <code>scheme://host/path</code> 创建标识符, <code>parameters</code> 信息将直接忽略, 以识别时效性 URL 下载任务.</li><li>精细任务状态<br>　　无/预处理/等待/进行中/完成/取消/暂停/恢复/校验/错误, 基本上都有 <code>will</code> 和 <code>did</code> 双重级别.</li><li>文件校验<br>　　支持 MD5, SHA1, SHA256, SHA512, 但校验特大文件时, CPU占用过大, 所以默认配置为关闭验证.</li><li>兼容 Swift<br>　　支持在 Swift 项目中进行使用.</li></ul><h4 id="FKDownloader-简单使用"><a href="#FKDownloader-简单使用" class="headerlink" title="FKDownloader 简单使用"></a>FKDownloader 简单使用</h4><ul><li>任务管理</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// 添加任务, 但不执行, 适合批量添加任务的场景</span><br><span class="line">[[FKDownloadManager manager] add:@“URL”];</span><br><span class="line"></span><br><span class="line">// 添加任务, 并附加额外信息, 目前支持 URL, 自定义保存文件名, 校验值, 校验类型, 自定义请求头</span><br><span class="line">[[FKDownloadManager manager] addInfo:@&#123;FKTaskInfoURL: url,</span><br><span class="line">                                       FKTaskInfoFileName: @&quot;xCode7&quot;,</span><br><span class="line">                                       FKTaskInfoVerificationType: @(VerifyTypeMD5),</span><br><span class="line">                                       FKTaskInfoVerification: @&quot;5f75fe52c15566a12b012db21808ad8c&quot;,</span><br><span class="line">                                       FKTaskInfoRequestHeader: @&#123;&#125; &#125;];</span><br><span class="line"></span><br><span class="line">// 开始执行任务</span><br><span class="line">[[FKDownloadManager manager] start:@“URL”];</span><br><span class="line"></span><br><span class="line">// 根据 URL 获取任务</span><br><span class="line">[[FKDownloadManager manager] acquire:@“URL”];</span><br><span class="line"></span><br><span class="line">// 暂停任务</span><br><span class="line">[[FKDownloadManager manager] suspend:@“URL”];</span><br><span class="line"></span><br><span class="line">// 恢复任务</span><br><span class="line">[[FKDownloadManager manager] resume:@“URL”];</span><br><span class="line"></span><br><span class="line">// 取消任务</span><br><span class="line">[[FKDownloadManager manager] cancel:@“URL”];</span><br><span class="line"></span><br><span class="line">// 移除任务</span><br><span class="line">[[FKDownloadManager manager] remove:@“URL”];</span><br><span class="line"></span><br><span class="line">// 设置任务代理</span><br><span class="line">[[FKDownloadManager manager] acquire:@“URL”].delegate = self;</span><br><span class="line"></span><br><span class="line">// 设置任务 Block</span><br><span class="line">[[FKDownloadManager manager] acquire:@“URL”].statusBlock = ^(FKTask *task) &#123;</span><br><span class="line">    // 状态改变时被调用</span><br><span class="line">&#125;;</span><br><span class="line">[[FKDownloadManager manager] acquire:@“URL”].speedBlock = ^(FKTask *task) &#123;</span><br><span class="line">    // 下载速度, 默认 1s 调用一次</span><br><span class="line">&#125;;</span><br><span class="line">[[FKDownloadManager manager] acquire:@“URL”].progressBlock = ^(FKTask *task) &#123;</span><br><span class="line">    // 进度改变时被调用</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>支持的任务通知</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 与代理同价, 可按照代理的使用方式使用通知.</span><br><span class="line">extern FKNotificationName const FKTaskPrepareNotification;</span><br><span class="line">extern FKNotificationName const FKTaskDidIdleNotification;</span><br><span class="line">extern FKNotificationName const FKTaskWillExecuteNotification;</span><br><span class="line">extern FKNotificationName const FKTaskDidExecuteNotication;</span><br><span class="line">extern FKNotificationName const FKTaskProgressNotication;</span><br><span class="line">extern FKNotificationName const FKTaskDidResumingNotification;</span><br><span class="line">extern FKNotificationName const FKTaskWillChecksumNotification;</span><br><span class="line">extern FKNotificationName const FKTaskDidChecksumNotification;</span><br><span class="line">extern FKNotificationName const FKTaskDidFinishNotication;</span><br><span class="line">extern FKNotificationName const FKTaskErrorNotication;</span><br><span class="line">extern FKNotificationName const FKTaskWillSuspendNotication;</span><br><span class="line">extern FKNotificationName const FKTaskDidSuspendNotication;</span><br><span class="line">extern FKNotificationName const FKTaskWillCancelldNotication;</span><br><span class="line">extern FKNotificationName const FKTaskDidCancelldNotication;</span><br><span class="line">extern FKNotificationName const FKTaskSpeedInfoNotication;</span><br></pre></td></tr></table></figure><ul><li>需要在 AppDelegate 中调用的</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)application:(UIApplication *)application handleEventsForBackgroundURLSession:(NSString *)identifier completionHandler:(void (^)(void))completionHandler &#123;</span><br><span class="line">    </span><br><span class="line">    // 保存后台下载所需的系统 Block, 区别 identifier 以防止与其他第三方冲突</span><br><span class="line">    if ([identifier isEqualToString:[FKDownloadManager manager].configure.sessionIdentifier]) &#123;</span><br><span class="line">        [FKDownloadManager manager].configure.backgroundHandler = completionHandler;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="FKDownloader-处理的一些细节"><a href="#FKDownloader-处理的一些细节" class="headerlink" title="FKDownloader 处理的一些细节"></a>FKDownloader 处理的一些细节</h4><ul><li>ResumeData<br>　　恢复数据在 iOS 10.0/10.1 中出现了格式错误, 官方在 iOS 10.2 中修复成功, 但为了兼容, 还是需要修复一番的, 具体解决方案在<a href="https://stackoverflow.com/questions/39346231/resume-nsurlsession-on-ios10/39347461#39347461" target="_blank" rel="noopener">这里</a>.<br>　　而在 iOS 11 中, 因为多出了 <code>NSURLSessionResumeByteRange</code> 字段导致一些奇怪的问题, 可以使用 <code>FKResumeHelper</code> 先读取, 在删除字段, 然后封包, 也可自己进行删除, 目前 FKDownloader 已自行处理.<br>　　虽然没有出错, 但在 iOS 12 中, ResumeData 的封包格式发生了改变, <del>现在可使用 <code>+[NSKeyedUnarchiver unarchiveObjectWithData:]</code> 直接进行解包</del>, 现在可以使用 <code>-[NSKeyedUnarchiver decodeTopLevelObjectForKey:error:]</code> 方法, <code>key</code> 为 <code>NSKeyedArchiveRootObjectKey</code> 来进行解包(而系统默认的 <code>key</code> 是 <code>root</code>, Apple 我不是很懂你啊😂), 但之前版本需要使用 <code>+[NSPropertyListSerialization propertyListWithData:roptions:format:error:]</code> 进行解包, 封包时也要注意区分.<br>　　在 iOS 8 中, 因为 <code>NSURLSessionResumeInfoVersion</code> 版本过旧, 新版本的 <code>NSURLSessionResumeInfoTempFileName</code> 会被 <code>NSURLSessionResumeInfoLocalPath</code> 代替, 缓存文件路径将不再只是文件名, 而是文件路径, 需要注意, 但影响不大, 运行并无问题.<br>　　<img src="https://user-gold-cdn.xitu.io/2018/11/23/1673fc0c1f0fd8a5?w=300&amp;h=168&amp;f=gif&amp;s=1899300" alt="Apple 就是可以为所欲为"></li></ul><p>　　</p><ul><li><p>文件校验<br>　　在下载一些大文件时, 为了保证文件完整性而需要进行文件校验, <code>FKDownloader</code> 可配置是否开启文件校验.<br>　　其中, 使用 <code>NSDataReadingMappedIfSafe</code> 选项进行初始化 <code>NSData</code>, 以防止超大文件导致内存溢出.<br>　　经过测试, 6G 大小的文件算出 MD5 需要 4~5秒, 内存占用 &lt; 1M, 但因为 Hash 操作为计算密集型, 导致 CPU 占用 &gt; 90%, 所以一般情况下, 下载小型文件时可开启文件校验, 但超大文件请酌情处理.</p></li><li><p>NSURLSessionDownloadTask<br>　　在调用 <code>-[NSURLSessionDownloadTask cancelByProducingResumeData:]</code> 后, 虽然任务状态改变为 <code>NSURLSessionTaskStateCanceling</code>, 但在之后代理 <code>-[URLSession URLSession:task:didCompleteWithError:]</code> 中获取, 状态为 <code>NSURLSessionTaskStateCompleted</code>, 差点被坑的不轻, 所以目前状态管理完全由 <code>FKTask</code> 的 <code>status</code> 属性代劳.</p></li><li><p>网络可达性 Network Reachability<br>　　使用 <a href="https://developer.apple.com/library/archive/samplecode/Reachability/Introduction/Intro.html" target="_blank" rel="noopener">官方文件</a> 处理网络状态的检测与监听, 但官方的方式只适合真机运行, 在虚拟机中只可监听到失去网络的状态, 而再次连接网络的状态无法获取, 但在真机中所有状态都可监听, 所以测试网络状态时请使用真机测试.</p></li></ul><h4 id="FKDownloader-最佳实践"><a href="#FKDownloader-最佳实践" class="headerlink" title="FKDownloader 最佳实践"></a>FKDownloader 最佳实践</h4><p>请查看运行 <a href="https://github.com/SYFH/FKDownloader" target="_blank" rel="noopener">Demo</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;接触-BUG&quot;&gt;&lt;a href=&quot;#接触-BUG&quot; class=&quot;headerlink&quot; title=&quot;接触 BUG&quot;&gt;&lt;/a&gt;接触 BUG&lt;/h4&gt;&lt;p&gt;　　前几天突然收到一朋友发来的消息, 说是在 iOS 12 上遇到了一个新的 BUG, 问我怎么看? 我说新系统遇到 BUG 不是很正常吗? 大概是个什么情况?&lt;br&gt;　　经过朋友说明, 大概是这么个现象: 他用了一个第三方下载管理器进行视频下载, 明明是设置了后台下载的, 但 App 一推到后台再回到前台, 下载进度就不动了, 但任务依然还在继续下载. 系统是 iOS 12, 手机是 iPhone 7.&lt;br&gt;　　&lt;br&gt;
    
    </summary>
    
      <category term="开发学习" scheme="http://norld.com/categories/%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="iOS" scheme="http://norld.com/tags/iOS/"/>
    
      <category term="后台下载" scheme="http://norld.com/tags/%E5%90%8E%E5%8F%B0%E4%B8%8B%E8%BD%BD/"/>
    
      <category term="FKDownloader" scheme="http://norld.com/tags/FKDownloader/"/>
    
      <category term="NSURLSession" scheme="http://norld.com/tags/NSURLSession/"/>
    
      <category term="NSURLSessionDownloadTask" scheme="http://norld.com/tags/NSURLSessionDownloadTask/"/>
    
      <category term="第三方库" scheme="http://norld.com/tags/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
      <category term="iOS BUG" scheme="http://norld.com/tags/iOS-BUG/"/>
    
  </entry>
  
  <entry>
    <title>获取 XCAsset 中 mp4, mp3 等非图片资源</title>
    <link href="http://norld.com/2017/12/22/%E8%8E%B7%E5%8F%96%20XCAsset%20%E4%B8%AD%20mp4,%20mp3%20%E7%AD%89%E9%9D%9E%E5%9B%BE%E7%89%87%E8%B5%84%E6%BA%90/"/>
    <id>http://norld.com/2017/12/22/获取 XCAsset 中 mp4, mp3 等非图片资源/</id>
    <published>2017-12-22T07:38:50.000Z</published>
    <updated>2017-12-22T07:47:46.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>在 <code>xcasset</code> 添加 <code>Data Set</code> 内容, 如 <code>.mp3</code>, <code>.mp4</code> 等非图片内容时, 通过 <code>NSBundle</code> 无法获取文件路径, <code>-[NSBundle pathForResource:ofType:]</code> 方法返回为 <code>nil</code>.</p><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>不改变文件存放位置的前提下, 获取文件的路径或二进制内容.</p><a id="more"></a><h3 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h3><p><code>Assets.xcassets</code> 内选择 <code>+</code> -&gt; 选择 <code>New Data Set</code>, 将 <code>demo.mp4</code> 添加到指定位置, Set 的名字重名为 <code>test</code>.</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>通过 <code>NSDataAsset</code> 类来获取 <code>xcasset</code> 文件夹内的文件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// xcasset 内包含 test.mp4 Data Set</span><br><span class="line">NSString *fileName = @&quot;test&quot;;</span><br><span class="line">NSDataAsset *dataAsset = [[NSDataAsset alloc] initWithName:fileName];</span><br><span class="line">[dataAsset.data writeToFile:/* save file path */ atomically:YES]</span><br><span class="line">NSURL *filePath = [NSURL fileURLWithPath:/* save file path */];</span><br></pre></td></tr></table></figure><p>至此, 就可以获取 <code>xcasset</code> 中非图片资源了</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p><code>NSDataAsset</code> 为 <font color="red"><strong>iOS 9.0 及以上</strong></font> 才可使用的方法</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul><li><a href="https://developer.apple.com/documentation/uikit/nsdataasset?language=objc" target="_blank" rel="noopener">NSDataAsset</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;场景&quot;&gt;&lt;a href=&quot;#场景&quot; class=&quot;headerlink&quot; title=&quot;场景&quot;&gt;&lt;/a&gt;场景&lt;/h3&gt;&lt;p&gt;在 &lt;code&gt;xcasset&lt;/code&gt; 添加 &lt;code&gt;Data Set&lt;/code&gt; 内容, 如 &lt;code&gt;.mp3&lt;/code&gt;, &lt;code&gt;.mp4&lt;/code&gt; 等非图片内容时, 通过 &lt;code&gt;NSBundle&lt;/code&gt; 无法获取文件路径, &lt;code&gt;-[NSBundle pathForResource:ofType:]&lt;/code&gt; 方法返回为 &lt;code&gt;nil&lt;/code&gt;.&lt;/p&gt;&lt;h3 id=&quot;目标&quot;&gt;&lt;a href=&quot;#目标&quot; class=&quot;headerlink&quot; title=&quot;目标&quot;&gt;&lt;/a&gt;目标&lt;/h3&gt;&lt;p&gt;不改变文件存放位置的前提下, 获取文件的路径或二进制内容.&lt;/p&gt;
    
    </summary>
    
      <category term="开发学习" scheme="http://norld.com/categories/%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="iOS" scheme="http://norld.com/tags/iOS/"/>
    
      <category term="XCAsset" scheme="http://norld.com/tags/XCAsset/"/>
    
      <category term="日积月累" scheme="http://norld.com/tags/%E6%97%A5%E7%A7%AF%E6%9C%88%E7%B4%AF/"/>
    
      <category term="编程技巧" scheme="http://norld.com/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>Core Foundation 学习 -- 图片质量的压缩与转换</title>
    <link href="http://norld.com/2017/03/21/Core%20Foundation%20%E5%AD%A6%E4%B9%A0%20--%20%E5%9B%BE%E7%89%87%E8%B4%A8%E9%87%8F%E7%9A%84%E5%8E%8B%E7%BC%A9%E4%B8%8E%E8%BD%AC%E6%8D%A2/"/>
    <id>http://norld.com/2017/03/21/Core Foundation 学习 -- 图片质量的压缩与转换/</id>
    <published>2017-03-21T10:02:00.000Z</published>
    <updated>2017-03-22T06:01:17.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>&emsp;&emsp;在 UIKit 中有两种图片质量压缩与转换的写法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UIImageJPEGRepresentation(image, 0.75);</span><br><span class="line">UIImagePNGRepresentation(image);</span><br></pre></td></tr></table></figure><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>&emsp;&emsp;用 <code>Core Foundation</code> 实现相同功能</p><a id="more"></a><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ul><li>创建 <code>Translate</code> 类的相关文件<ul><li>包含 <code>Translate.h</code> 和 <code>Translate.m</code> 文件</li><li>删除所有 <code>@interface</code> 和 <code>@implementation</code> 相关的内容<ul><li>这一步可不做, 之后的内容并没有操作 <code>Translate</code> 的类或实例对象</li></ul></li></ul></li><li><p>在 <code>Translate.h</code> 中</p><ul><li><p>创建结果相关的 Blok</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef void(^complet)(BOOL isSuccess);</span><br></pre></td></tr></table></figure></li><li><p>创建格式转换相关的枚举</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSUInteger, kUTType) &#123;</span><br><span class="line">    kUTTypeJPEG,</span><br><span class="line">    kUTTypePNG</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>声明定义压缩转换方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extern void TImageRepresentation(NSString *sourceImagePath,NSString *targetImagePatch,double compressionQuality,kUTType type,complet complet);</span><br></pre></td></tr></table></figure></li></ul></li></ul><blockquote><table><thead><tr><th>参数</th><th>格式</th><th>定义</th></tr></thead><tbody><tr><td>sourceImagePath</td><td><code>NSString *</code></td><td>原图片文件路径</td></tr><tr><td>targetImagePatch</td><td><code>NSString *</code></td><td>输出路径, 必须包含文件名与后缀</td></tr><tr><td>compressionQuality</td><td><code>double</code></td><td>图片压缩质量, 范围 0~1, 1为最高质量</td></tr><tr><td>type</td><td><code>kUTType</code></td><td>输出格式, 务必与输出路径的后缀相同</td></tr><tr><td>complet</td><td><code>Block</code></td><td>输出结果的回调</td></tr></tbody></table></blockquote><ul><li><p>在 <code>Translate.m</code> 中</p><ul><li><p>引入相关头文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;ImageIO/ImageIO.h&gt;</span><br><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br></pre></td></tr></table></figure></li><li><p>开始实现压缩转换方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void TImageRepresentation(NSString *sourceImagePath,</span><br><span class="line">                          NSString *targetImagePatch,</span><br><span class="line">                          double compressionQuality,</span><br><span class="line">                          kUTType type,</span><br><span class="line">                          complet complet) &#123;</span><br><span class="line">    // do something...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>开启子线程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">    // do something...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获取图片源数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CGImageRef image = [UIImage imageWithContentsOfFile:sourceImagePath].CGImage;</span><br></pre></td></tr></table></figure></li><li><p>创建接收最终数据的目标容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CFMutableDataRef imageData = CFDataCreateMutable(NULL, 0);</span><br></pre></td></tr></table></figure></li><li><p>判断转换格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CFStringRef typeStr;</span><br><span class="line">switch (type) &#123;</span><br><span class="line">    case kUTTypeJPEG:</span><br><span class="line">        typeStr = CFSTR(&quot;public.jpeg&quot;);</span><br><span class="line">        break;</span><br><span class="line">            </span><br><span class="line">    case kUTTypePNG:</span><br><span class="line">        typeStr = CFSTR(&quot;public.png&quot;);</span><br><span class="line">        break;</span><br><span class="line">            </span><br><span class="line">    default:</span><br><span class="line">        break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建转换者对象, 进行质量压缩和转换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CGImageDestinationRef destination = CGImageDestinationCreateWithData(imageData, typeStr, 1, NULL);</span><br></pre></td></tr></table></figure><p><code>CGImageDestinationCreateWithData(_,_,_,_)</code> 函数的<a href="https://developer.apple.com/reference/imageio/1465133-cgimagedestinationcreatewithdata?language=objc" target="_blank" rel="noopener">相关详情</a></p></li><li><p>创建所需参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSDictionary *properties = @&#123; (__bridge id)kCGImagePropertyMakerNikonQuality : @(compressionQuality) &#125;;</span><br></pre></td></tr></table></figure></li><li><p>向转换者对象添加图片数据和参数数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CGImageDestinationAddImage(destination, image, (__bridge CFDictionaryRef)properties);</span><br></pre></td></tr></table></figure><p><code>CGImageDestinationAddImage(_,_,_)</code> 函数的<a href="https://developer.apple.com/reference/imageio/1464962-cgimagedestinationaddimage?language=objc" target="_blank" rel="noopener">相关详情</a></p></li><li><p>检测转换是否成功, 如失败直接释放数据源与转换者对象, 并结束所有流程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if (!CGImageDestinationFinalize(destination)) &#123;</span><br><span class="line">    CFRelease(imageData);</span><br><span class="line">    imageData = NULL;</span><br><span class="line">    if (complet) &#123;</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            complet(NO);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    // 释放转换者对象</span><br><span class="line">    CFRelease(destination);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>成功后释放转换者对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CFRelease(destination);</span><br></pre></td></tr></table></figure></li><li><p>根据输出地址, 创建输出流</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CFAllocatorRef allocator = CFAllocatorGetDefault();</span><br><span class="line">NSURL *fileUrl = [NSURL fileURLWithPath:targetImagePatch];</span><br><span class="line">CFWriteStreamRef writeStream = CFWriteStreamCreateWithFile(allocator, (__bridge CFURLRef)fileUrl);</span><br></pre></td></tr></table></figure></li><li><p>开启输出流</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CFWriteStreamOpen(writeStream);</span><br></pre></td></tr></table></figure></li><li><p>向目标容器写入最终数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CFIndex result = CFWriteStreamWrite(writeStream, CFDataGetBytePtr(imageData), CFDataGetLength(imageData));</span><br></pre></td></tr></table></figure><p><code>CFWriteStreamWrite(_,_,_)</code> 函数的<a href="https://developer.apple.com/reference/corefoundation/1539680-cfwritestreamwrite?language=objc" target="_blank" rel="noopener">相关详情</a></p></li><li><p>判断最终数据写入是否成功</p><p>&emsp;&emsp;不成功的返回值为 -1, 成功则为输出的字节流长度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">if (result != -1) &#123;</span><br><span class="line">    if (complet) &#123;</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            complet(YES);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    if (complet) &#123;</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            complet(NO);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>关闭输出流</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CFWriteStreamClose(writeStream);</span><br></pre></td></tr></table></figure></li><li><p>释放目标容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CFRelease(imageData);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>&emsp;&emsp;简单使用:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">NSString *sourceImagePath = @&quot;要进行处理的图片的路径&quot;;</span><br><span class="line">NSString *targetImagePath = @&quot;处理完成的输出路径&quot;;</span><br><span class="line">double compressionQuality = 0.75f;</span><br><span class="line">kUTType targetImageType = kUTTypeJPEG;</span><br><span class="line">    </span><br><span class="line">TImageRepresentation(sourceImagePath, targetImagePath, compressionQuality, targetImageType, ^(BOOL isSuccess) &#123;</span><br><span class="line">    if (isSuccess) &#123;</span><br><span class="line">        NSLog(@&quot;Winer&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        NSLog(@&quot;Loser&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h3><ul><li><p><a href="https://developer.apple.com/reference/imageio/cgimagedestination?language=objc" target="_blank" rel="noopener">Apple 文档 - CGImage​Destination</a></p></li><li><p><a href="https://developer.apple.com/reference/corefoundation/cfwritestream?language=objc" target="_blank" rel="noopener">Apple 文档 - CFWrite​Stream</a></p></li><li><p><a href="https://developer.apple.com/reference/mobilecoreservices/uttype?language=objc" target="_blank" rel="noopener">Apple 文档 - UTType</a></p></li><li><p><a href="https://developer.apple.com/library/content/documentation/FileManagement/Conceptual/understanding_utis/understand_utis_conc/understand_utis_conc.html#//apple_ref/doc/uid/TP40001319-CH202-BCGJGJGA" target="_blank" rel="noopener">Apple 文档 - 统一类型标识符 UTI</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;开始&quot;&gt;&lt;a href=&quot;#开始&quot; class=&quot;headerlink&quot; title=&quot;开始&quot;&gt;&lt;/a&gt;开始&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;在 UIKit 中有两种图片质量压缩与转换的写法:&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;UIImageJPEGRepresentation(image, 0.75);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;UIImagePNGRepresentation(image);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h3 id=&quot;目标&quot;&gt;&lt;a href=&quot;#目标&quot; class=&quot;headerlink&quot; title=&quot;目标&quot;&gt;&lt;/a&gt;目标&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;用 &lt;code&gt;Core Foundation&lt;/code&gt; 实现相同功能&lt;/p&gt;
    
    </summary>
    
      <category term="开发学习" scheme="http://norld.com/categories/%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="iOS" scheme="http://norld.com/tags/iOS/"/>
    
      <category term="Core Foundation" scheme="http://norld.com/tags/Core-Foundation/"/>
    
      <category term="Image I/O" scheme="http://norld.com/tags/Image-I-O/"/>
    
      <category term="仿制系统系列" scheme="http://norld.com/tags/%E4%BB%BF%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%B3%BB%E5%88%97/"/>
    
      <category term="图片质量压缩" scheme="http://norld.com/tags/%E5%9B%BE%E7%89%87%E8%B4%A8%E9%87%8F%E5%8E%8B%E7%BC%A9/"/>
    
      <category term="图片转换" scheme="http://norld.com/tags/%E5%9B%BE%E7%89%87%E8%BD%AC%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>深入理解 [super init]</title>
    <link href="http://norld.com/2017/03/15/%E6%B7%B1%E5%BA%A6%E7%90%86%E8%A7%A3%20super%20init/"/>
    <id>http://norld.com/2017/03/15/深度理解 super init/</id>
    <published>2017-03-15T07:02:00.000Z</published>
    <updated>2017-03-16T08:37:55.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>&emsp;&emsp;创建一个 <code>Test</code> 测试类, 重写初始化方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)init &#123;</span><br><span class="line">   self = [super init];</span><br><span class="line">   if (self) &#123;</span><br><span class="line">       // do something...</span><br><span class="line">   &#125;</span><br><span class="line">   return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="疑问"><a href="#疑问" class="headerlink" title="疑问:"></a>疑问:</h3><ul><li>为何要执行 <code>[super init]</code> ?</li><li><code>[super init]</code> 的结果为何要 <code>self</code> 接收?</li></ul><a id="more"></a><h3 id="探索"><a href="#探索" class="headerlink" title="探索:"></a>探索:</h3><ul><li><code>[super init]</code></li></ul><p>&emsp;&emsp;这一句看起来很有迷惑性, 一个 <code>super</code> 关键字, 好像初始化的是父类, 但在码代码的时候可以注意一个细节: 在写 <code>self</code> 时, 代码提示是有返回值类型的, 而写 <code>[super init]</code> 时, 并没有返回值类型, 但在别处写 <code>super</code> 时, 自动提示的返回值类型是父类.</p><p>&emsp;&emsp;这表示在 <code>[super init]</code> 这句话中, <code>super</code> 并不是指父类, 可能只是一个没有什么卵用的关键字, 但在苹果的官方文档中, 这么写是推荐的写法, 那么这句话就很关键了.</p><p>&emsp;&emsp;通过 <code>clang -rewrite-objc Test.m</code> 命令, 重新编译成 cpp 文件, 可以看到这一行代码究竟做了什么:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static instancetype _I_Test_init(Test * self, SEL _cmd) &#123;</span><br><span class="line">    self = ((Test *(*)(__rw_objc_super *, SEL))(void *)objc_msgSendSuper)((__rw_objc_super)&#123;(id)self, (id)class_getSuperclass(objc_getClass(&quot;Test&quot;))&#125;, sel_registerName(&quot;init&quot;));</span><br><span class="line">    if (self) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;经过简化后, <code>[super init]</code> 就变为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_msgSendSuper(&#123;self, class_getSuperclass(objc_getClass(&quot;Test&quot;))&#125;, sel_registerName(&quot;init&quot;));</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;而其中 <code>objc_msgSendSuper()</code> 这个方法, API 文档是这样描述的:</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OBJC_EXPORT void objc_msgSendSuper(void /* struct objc_super *super, SEL op, ... */ )  OBJC_AVAILABLE(10.0, 2.0, 9.0, 1.0);</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>Sends a message with a simple return value to the superclass of an instance of a class.<br>将具有返回值的消息发送到一个实例的超类.</p></blockquote><p>&emsp;&emsp;第一个参数是 <code>objc_suoer</code> 类型的结构体, 第二个或更多是 <code>SEL</code> 方法选择器, 而在 <code>runtime.m</code> 文档中, <code>objc_super</code> 的结构为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct objc_super &#123;</span><br><span class="line">    __unsafe_unretained id receiver;</span><br><span class="line">    __unsafe_unretained Class super_class;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<code>receiver</code> 是实例对象, <code>super_class</code> 是用来接收消息的类, 为实例对象的父类.</p><p>&emsp;&emsp;在当前的代码里, <code>receiver</code> 为 <code>self</code> , <code>super_class</code> 为 <code>NSObject</code> .</p><p>&emsp;&emsp;再回过头来, 注意看 <code>[super init]</code> 的 c++ 源码, 返回值为 <code>Test *</code>, 所以在这里的 <code>init</code> 只是向上初始化父类而已.</p><p>&emsp;&emsp;那么这就明了了, <code>[super init]</code> 只是为了将父类, 父类的父类, 父类的父类的父类等等等等, 从 <code>NSObject</code> 开始的所有类都初始化了一遍, 只是为了确保父类的方法, 属性都能正确使用而已.</p><ul><li><code>self = [super init]</code></li></ul><p>&emsp;&emsp;既然明白了 <code>[super init]</code> 做了什么, 那么返回结果再赋值给 <code>self</code> 就基本没有疑问了: 如果在 <code>[super init]</code> 这一步因为一些不明的原因导致初始化失败, 那么返回值应该是为 <code>nil</code> 的, 这时候让 <code>self</code> 接收一下, 之后用 <code>if</code> 判断, 则可以避免一些 BUG.</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>为何要执行 <code>[super init]</code> ?<ul><li>为了将当前实例的父类树进行初始化, 以保证继承父类树的所有属性与方法.</li></ul></li><li><code>[super init]</code> 的结果为何要 <code>self</code> 接收?<ul><li>为了确保初始化不会因为失败而 crash.</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;开始&quot;&gt;&lt;a href=&quot;#开始&quot; class=&quot;headerlink&quot; title=&quot;开始&quot;&gt;&lt;/a&gt;开始&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;创建一个 &lt;code&gt;Test&lt;/code&gt; 测试类, 重写初始化方法:&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (instancetype)init &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   self = [super init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   if (self) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       // do something...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   return self;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h3 id=&quot;疑问&quot;&gt;&lt;a href=&quot;#疑问&quot; class=&quot;headerlink&quot; title=&quot;疑问:&quot;&gt;&lt;/a&gt;疑问:&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;为何要执行 &lt;code&gt;[super init]&lt;/code&gt; ?&lt;/li&gt;&lt;li&gt;&lt;code&gt;[super init]&lt;/code&gt; 的结果为何要 &lt;code&gt;self&lt;/code&gt; 接收?&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="开发学习" scheme="http://norld.com/categories/%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="iOS" scheme="http://norld.com/tags/iOS/"/>
    
      <category term="Runtime" scheme="http://norld.com/tags/Runtime/"/>
    
      <category term="深入理解" scheme="http://norld.com/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>HelloWorld</title>
    <link href="http://norld.com/2017/01/13/HelloWorld/"/>
    <id>http://norld.com/2017/01/13/HelloWorld/</id>
    <published>2017-01-13T04:33:00.000Z</published>
    <updated>2017-07-12T05:57:23.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="新的开始"><a href="#新的开始" class="headerlink" title="新的开始"></a>新的开始</h3><p>hello world!<br><a id="more"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;Foundation/Foundation.h&quot;</span><br><span class="line"></span><br><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    NSLog(@&quot;Hello world!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;新的开始&quot;&gt;&lt;a href=&quot;#新的开始&quot; class=&quot;headerlink&quot; title=&quot;新的开始&quot;&gt;&lt;/a&gt;新的开始&lt;/h3&gt;&lt;p&gt;hello world!&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
