<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 4.2.1"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"syfh.github.io",root:"/",scheme:"Pisces",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!1,show_result:!1,style:null},back2top:{enable:!0,sidebar:!1,scrollpercent:!1},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!1,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}}}</script><meta name="description" content="前言当初编写 0.x 版本时, 尚未考虑过多逻辑, 整体架构就是简单的封装系统逻辑, 导致在后期频频出问题, 而打补丁只会出更多的问题, 毕竟底子并没有打好, 所以就起了重构的心思."><meta property="og:type" content="article"><meta property="og:title" content="对 FKDownloader 的完全重构"><meta property="og:url" content="https://syfh.github.io/2020/02/03/%E5%AF%B9%20FKDownloader%20%E7%9A%84%E5%AE%8C%E5%85%A8%E9%87%8D%E6%9E%84/index.html"><meta property="og:site_name" content="Norld&#39;s Blog"><meta property="og:description" content="前言当初编写 0.x 版本时, 尚未考虑过多逻辑, 整体架构就是简单的封装系统逻辑, 导致在后期频频出问题, 而打补丁只会出更多的问题, 毕竟底子并没有打好, 所以就起了重构的心思."><meta property="og:image" content="https://pic.downk.cc/item/5e4d253e48b86553eea38f27.png"><meta property="article:published_time" content="2020-02-03T05:46:30.000Z"><meta property="article:modified_time" content="2020-03-22T04:18:02.000Z"><meta property="article:author" content="Norld"><meta property="article:tag" content="iOS"><meta property="article:tag" content="后台下载"><meta property="article:tag" content="FKDownloader"><meta property="article:tag" content="NSURLSession"><meta property="article:tag" content="NSURLDownloadTask"><meta property="article:tag" content="重构"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://pic.downk.cc/item/5e4d253e48b86553eea38f27.png"><link rel="canonical" href="https://syfh.github.io/2020/02/03/%E5%AF%B9%20FKDownloader%20%E7%9A%84%E5%AE%8C%E5%85%A8%E9%87%8D%E6%9E%84/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-Hans"}</script><title>对 FKDownloader 的完全重构 | Norld's Blog</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><link rel="alternate" href="/atom.xml" title="Norld's Blog" type="application/atom+xml">
</head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="Toggle navigation bar"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">Norld's Blog</h1><span class="logo-line-after"><i></i></span></a></div><div class="site-nav-right"><div class="toggle popup-trigger"></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li></ul></nav></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans"><link itemprop="mainEntityOfPage" href="https://syfh.github.io/2020/02/03/%E5%AF%B9%20FKDownloader%20%E7%9A%84%E5%AE%8C%E5%85%A8%E9%87%8D%E6%9E%84/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="https://norldblog.oss-cn-shanghai.aliyuncs.com/avatar.jpg"><meta itemprop="name" content="Norld"><meta itemprop="description" content="众所周知, 这隐藏着真理<br>显而易见, 这值得去探索"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Norld's Blog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">对 FKDownloader 的完全重构</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2020-02-03 13:46:30" itemprop="dateCreated datePublished" datetime="2020-02-03T13:46:30+08:00">2020-02-03</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">Edited on</span> <time title="Modified: 2020-03-22 12:18:02" itemprop="dateModified" datetime="2020-03-22T12:18:02+08:00">2020-03-22</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">开发学习</span></a> </span></span><span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">Views: </span><span id="busuanzi_value_page_pv"></span></span></div></header><div class="post-body" itemprop="articleBody"><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>当初编写 0.x 版本时, 尚未考虑过多逻辑, 整体架构就是简单的封装系统逻辑, 导致在后期频频出问题, 而打补丁只会出更多的问题, 毕竟底子并没有打好, 所以就起了重构的心思.</p><a id="more"></a><h3 id="灵感"><a href="#灵感" class="headerlink" title="灵感"></a>灵感</h3><p>刚一开始想参考一下 <code>aria2</code> 这个大佬级下载软件, 但奈何这软件涉及的下载方式过于复杂, 而且 iOS 的封闭式导致大部分逻辑不能使用, 强行借鉴是没有好下场的, 只好另作打算.</p><p>之前因为需要为自己的 App 编写后台, 就接触到了 Python, 当时为了将一些资源整合到自己的数据库中, 就发现了 <code>Scrapy</code> 这个大名鼎鼎的爬虫框架, 而这个框架的逻辑恰好符合我的想法.</p><p>根据 iOS 下载系统的特性, 下载框架会按下图的流程进行制作:<br><img src="https://pic.downk.cc/item/5e4d253e48b86553eea38f27.png"></p><p>至于为什么要这么做, 主要还是得看制作一个后台下载框架都有什么难点.</p><h3 id="后台下载框架主要难点与关键点"><a href="#后台下载框架主要难点与关键点" class="headerlink" title="后台下载框架主要难点与关键点"></a>后台下载框架主要难点与关键点</h3><ol><li><p>下载任务和下载流程全部归系统管理<br>首先, iOS 后台下载的主要流程基本为: 创建 <code>NSURL</code> -&gt; 创建 <code>NSURLRequest</code> -&gt; 使用 <code>Session</code> 和 <code>NSURLRequest</code> 生成 <code>NSURLSessionDownloadTask</code>, 之后的下载信息, 如下载进度, 下载失败和下载成功等事件可以通过设置代理后获得.</p><p>然后, 如何在重启 App 后获得下载任务? 可以通过 <code>-[NSURLSession getTasksWithCompletionHandler:]</code> 获取.</p><p>但这个方法真的能获取所有请求吗? 官方文档有解释:</p><blockquote><p>The arrays passed to the completion handler contain any tasks that you have created within the session, not including any tasks that have been invalidated after completing, failing, or being cancelled.</p></blockquote><p>显而易见, 对于已经失效的任务是获取不到的, 所以拥有一套任务记录模块是必须的.</p><p>还有一种情况, 链接重定向, 这会导致拿到 <code>NSURLSessionDownloadTask</code> 后, 不知道对应那个下载链接, 这种情况的解决方案有几种, 可以监听 <code>NSURLSessionDownloadTask</code> 的 <code>currentRequest</code> 属性来记录最终下载链接, 也可以使用 <code>taskDescription</code> 属性放置一个标记, 当然, 也许还有其他方法.</p></li><li><p>获取任务进度的自由度<br>对于 <code>NSURLSessionDownloadTask</code>, 有 <code>countOfBytesReceived</code> 和 <code>countOfBytesExpectedToReceive</code> 这两个属性可以获取已下载字节长度和预计全部数据长度, 还有一些新的属性也可以获取这些信息.</p><p>显然, 对于单一任务来说, 这已经足够了, 但对于多个任务, 并且可以任意分组的情况来说, 那就需要一个统一记录进度的模块了.</p></li><li><p>奇奇怪怪得系统 BUG<br>这些个 BUG 虽然都有应对方法, 但部分应对方法会影响一些逻辑.</p><p>比如在 <code>iOS 12/12.1, iPhone 8</code> 以下机型会出现 <code>NSURLSessionDownloadTask</code> 的 <code>countOfBytesReceived</code> 和 <code>countOfBytesExpectedToReceive</code> 属性在进入后台, 再回到前台后, 不再变更数值的问题, 需要来一个暂停/恢复的改变才会继续工作, 这就需要框架有一个监听前/后台切换的逻辑, 去处理这个问题.</p><p>还有那个恢复数据有问题导致恢复下载失败的问题, 需要在每次恢复下载时做一次修复处理, 对于一些需要将恢复数据保存到本地的逻辑来说, 就需要特殊逻辑来使这些逻辑共存.</p><p>对于 Apple 来说, 后台下载这些逻辑明显是不想让开发者过多干涉, 所以在出现一些问题时, 开发者很被动, 只能找着法子各种规避了.</p></li><li><p>任务列表<br>每个带有下载功能的 App 基本上都会有下载列表, 但在下载框架里, 最好不要现实下载列表功能, 这毕竟属于 App 的业务逻辑.</p><p>而且因为业务影响, UI 影响, 会导致数据结构千奇百怪, 第三方框架没必要兼容, 也兼容不了.</p><p>所以任务信息相关的模块最好保持懒加载模式, 需要的时候直接拿来用, UI 相关的数据只保留最基本的数据, 其他信息可以由 App 端实现.</p></li></ol><h3 id="框架模块"><a href="#框架模块" class="headerlink" title="框架模块"></a>框架模块</h3><p>接下来就是根据架构流程图创建各种模块了, 在 <code>FKDownloader</code> 中有两种类型的模块, 一种公开类型, 一种私有类型.</p><p>公开模块为面向用户的模块, 包含 <code>FKBuilder</code>(构建任务), <code>FKMessager</code>(获取信息), <code>FKConfigure</code>(下载配置), <code>FKControl</code>(控制任务), <code>FKMiddleware</code>(中间件) 五个模块.</p><p>私有模块为框架内部使用模块, 包含主要模块: <code>FKEngine</code>, <code>FKCache</code>, <code>FKObserver</code>, <code>FKScheduler</code>, <code>FKSessionDelegater</code>.</p><p>还有辅助模块: <code>FKSingleNumber</code>, <code>FKFileManager</code>, <code>FKLogger</code>, <code>FKCoder</code>, FKMIMEType.</p><p>还有一些数据模型: <code>FKObserverModel</code>, <code>FKCacheRequestModel</code>, <code>FKResponse</code>.</p><p>它们将按照流程图来处理下载任务, 大体上来讲, <code>FKBuilder</code> 是输入, <code>FKMessager</code> 是输出, <code>FKEngine</code> 是处理, <code>FKControl</code> 是控制, <code>FKCache</code> 是储存.</p><h3 id="框架模块详细讲解"><a href="#框架模块详细讲解" class="headerlink" title="框架模块详细讲解"></a>框架模块详细讲解</h3><p>首先, 是公开模块.</p><h5 id="FKBuilder"><a href="#FKBuilder" class="headerlink" title="FKBuilder"></a>FKBuilder</h5><p>该模块主要对应 <code>创建NSURLRequest</code> 阶段, 独立出来是为了更好的控制构建 <code>NSURLReqest</code> 的过程.</p><p>鉴于 NSURLReqest 的属性和方法会随着系统更新变得越来越多, 越来越复杂, 且自定义不会对生成 <code>NSURLSessionDownloadTask</code> 流程产生影响, 所以 <code>FKBuilder</code> 直接继承于 <code>NSMutableURLRequest</code>, 用户可以像操作 <code>NSMutableURLRequest</code> 一样操作 <code>FKBuilder</code>. 对于用户传入的 URL 是否合法, 也可在初始化时进行校验.</p><p><code>FKBuilder</code> 需要显式执行预处理, 这样才能将任务加入队列中.</p><h5 id="FKMessager"><a href="#FKMessager" class="headerlink" title="FKMessager"></a>FKMessager</h5><p>该模块对应请求信息收集逻辑, 比如进度、状态、错误等.</p><p>基本上所有有关下载的业务逻辑, 添加下载的界面和查看下载进度的是分开的, 所以, FKDownloader 就干脆将任务信息收集相关逻辑全部独立出来, 同时也可以更好的对应列表样式的信息获取.</p><h5 id="FKConfigure"><a href="#FKConfigure" class="headerlink" title="FKConfigure"></a>FKConfigure</h5><p>一个下载框架如果不能自定义配置, 那就没有灵魂.</p><p>查看 <code>NSURLSessionConfiguration</code> 的官方文档就会发现系统提供的参数巨多, 而且还包含了新版本特性, 这就导致对外开放什么属性/方法成了难题, 多了不可控, 少了又没有高度自定义那味, 所以 <code>FKConfigure</code> 直接提供了一个 <code>NSURLSessionConfiguration</code> 模版, 化为属性, 只把其中的能否使用蜂窝 <code>allowsCellularAccess</code> 默认设置为允许, 其他通通由用户自定义.</p><p>至于 <code>NSMutableURLRequest</code> 和 <code>NSURLSessionConfiguration</code> 的部分属性冲突, 这部分官方已经在注释里讲的很明白了, 用户可自行斟酌.</p><h5 id="FKControl"><a href="#FKControl" class="headerlink" title="FKControl"></a>FKControl</h5><p>这就是个控制任务的, 激活、暂停、继续、停止、删除, 没什么好说的, 独立出来只是为了面向用户, 不用跟其他私有模块产生冲突, 而且多出一层, 可操作性也会多一层.</p><h5 id="FKMiddleware"><a href="#FKMiddleware" class="headerlink" title="FKMiddleware"></a>FKMiddleware</h5><p>中间件模块, 我也就在爬虫框架和后端框架中见过, <code>FKDownloader</code> 中有这种模块主要是为了有一种可以统一处理的方式.</p><p>目前该模块只在生成 <code>NSURLSessionDownloadTask</code> 前, 下载成功/失败后会有介入, 前者是为了诸如请求统一加签、绕过浏览器限制等操作, 后者可以当成 <code>NSURLSession</code> 代理中下载成功/失败的回调即可.</p><p>更多的操作可根据业务自行调整.</p><hr><hr><p>再来是私有模块.</p><h5 id="FKEngine"><a href="#FKEngine" class="headerlink" title="FKEngine"></a>FKEngine</h5><p>该模块基本就是框架运转的核心.</p><p>在一般下载逻辑中, 会为每个任务创建一个计时器, 实现进度信息分发逻辑, 但这一块儿其实用不了那么多, 还会因为管理不过来出现问题(0.x版本就有这类问题), 所以在 <code>FKEngine</code> 中只有两个个计时器, 只为了更简洁的操作, 毕竟在实际业务中, 这些进度条各走各还是一起走都无所谓,</p><p>计时器主要完成以下任务:</p><ol><li>检查任务队列, 进行下一个任务</li></ol><p>首先, <code>FKBuilder</code> 的预处理会将生成的任务信息模型(<code>FKCacheRequestModel</code>) 存入 <code>FKCache</code> 的缓存队列中, 但不开始任务, 也不创建 <code>NSURLSessionDownloadTask</code>, 这是前提, 与计时器无关.</p><p>然后, 计时器被触发后就会检查队列中正在执行的任务是否超过设置, 超过了就什么也不做, 没超过就开始用任务信息创建 <code>NSURLSessionDownloadTask</code>, 进行下载, 期间走过中间件流程, 本地信息缓存流程, 监听信息流程等等流程.</p><p>执行任务计时器的间隔为 1s, 不可自定义.</p><ol start="2"><li>分发任务信息</li></ol><p>在使用 <code>FKMessager</code> 时, 回调会被缓存, 计时器被触发后将会轮询执行这些回调</p><p>以上任务都会在计时器触发后执行. 默认情况下, 这个计时器是停止的, 需要用 <code>FKConfigure</code> 来激活, 这是为了保证在 <code>NSURLSession</code> 被创建后再执行任务.</p><p>计时器重复时间默认设定为 1s, 这个时间刚刚好, 少了太频繁, 多了感觉慢.<br>也支持用户自定义速率, 目前 1 倍速率为 0.2 秒, 倍率在 1 ~ 10 倍区间可自定义.</p><p>除此之外, 应用启动后还会去查询后台已经存在的下载任务, 将这些任务添加到缓存中, 让它们和其他任务一致.</p><p>基本上其他模块只是制造信息, 输出信息和保存信息, 而 <code>FKEngine</code> 则是让整个框架活过来.</p><h5 id="FKCache"><a href="#FKCache" class="headerlink" title="FKCache"></a>FKCache</h5><p>主要负责信息缓存, 任务的信息, <code>NSURLSessionDownloadTask</code> 等等.</p><p>独立的缓存模块是必须的, 要缓存的信息有很多, 集中起来更容易管理.</p><p>在 <code>FKDownloader</code> 中, 对任务有一个主要理念: <code>任务即文件, 文件即任务</code>, 每一个任务都有一个属于自己的唯一标识, 标识与用户输入的链接息息相关, 也和本地缓存有着千丝万缕的联系.</p><p>在 <code>FKDownloader</code> 中的文件就是 <code>FKCacheRequestModel</code> 对应的归档文件, 这个模型提供的信息有:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, strong) NSString *requestID; &#x2F;&#x2F; 请求标识, SHA256(URL)</span><br><span class="line">@property (nonatomic, strong) NSString *requestSingleID; &#x2F;&#x2F; 唯一请求标识, SingleNumber_SHA256(URL)</span><br><span class="line">@property (nonatomic, strong) NSString *idx; &#x2F;&#x2F; 唯一顺序编码</span><br><span class="line">@property (nonatomic, strong) NSString *url; &#x2F;&#x2F; 原始请求链接</span><br><span class="line">@property (nonatomic, strong) NSMutableURLRequest *request; &#x2F;&#x2F; 请求</span><br><span class="line">@property (nonatomic, assign) FKState state; &#x2F;&#x2F; 请求状态</span><br><span class="line">@property (nonatomic, assign) int64_t receivedLength; &#x2F;&#x2F; 接收的数据长度</span><br><span class="line">@property (nonatomic, assign) int64_t dataLength; &#x2F;&#x2F; 数据长度</span><br><span class="line">@property (nonatomic, strong) NSString *extension; &#x2F;&#x2F; 文件后缀, &#96;.*&#96;</span><br><span class="line">@property (nonatomic, strong, nullable) NSData *resumeData; &#x2F;&#x2F; 恢复数据</span><br><span class="line">@property (nonatomic, strong, nullable) NSError *error; &#x2F;&#x2F; 错误</span><br></pre></td></tr></table></figure><p>基本上可以构成/恢复任务的信息都在里面, 每一个任务都有自己的文件夹保存这些信息, 分而治之有利于管理, 0.x版本中都是所有任务都在一个文件中, 不管从性能上看, 还是管理上看, 都有很大的问题.</p><h5 id="FKObserver"><a href="#FKObserver" class="headerlink" title="FKObserver"></a>FKObserver</h5><p>众多任务需要监听的流程太过繁杂也太过分散, 系统 BUG 还导致这些监听还需要重新添加, 这就更分散了. 而获取进度信息在业务上来讲并不频繁使用, 这些监听到的信息全放在任务信息模型里也不合适, 那么, 直接独立出来成模块岂不美哉.</p><p><code>FKObserver</code> 以专门监听 <code>NSURLSessionDownloadTask</code> 而生, 所有任务的进度信息都在这里.</p><p><code>FKObserver</code> 使用 <code>FKObserverModel</code> 保存进度信息, 基本信息如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@interface FKObserverModel : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong) NSString *requestID; &#x2F;&#x2F; SHA256(Request.URL)</span><br><span class="line">@property (nonatomic, assign) int64_t countOfBytesReceived;</span><br><span class="line">@property (nonatomic, assign) int64_t countOfBytesPreviousReceived;</span><br><span class="line">@property (nonatomic, assign) int64_t countOfBytesExpectedToReceive;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>简约而不简单, 并且和 <code>FKMessager</code> 配合完美, 一个对外, 一个对内.</p><h5 id="FKScheduler"><a href="#FKScheduler" class="headerlink" title="FKScheduler"></a>FKScheduler</h5><p><code>FKBuilder</code> 和 <code>FKEngine</code> 之间的模块, <code>FKControl</code> 的实现, 主要任务如下:</p><ol><li>对 <code>FKBuilder</code> 的预处理逻辑进行了更细节的处理. 如创建任务信息文件, 添加内存/本地缓存, 忽略已存在任务等.</li><li>实现 <code>FKControl</code> 的操作, 激活、暂停、继续、取消、删除.</li></ol><h5 id="FKSessionDelegater"><a href="#FKSessionDelegater" class="headerlink" title="FKSessionDelegater"></a>FKSessionDelegater</h5><p>实现 <code>NSURLSession</code> 的代理, 没啥好说, 单独摘出来是因为代理方法还是很多很复杂的, 为了之后更好的扩展, 这样更好一些.</p><hr><hr><p>还有一些辅助用模块</p><h5 id="FKSingleNumber"><a href="#FKSingleNumber" class="headerlink" title="FKSingleNumber"></a>FKSingleNumber</h5><p>在执行下一个任务时, 哪个才是下一个? 按添加顺序可不一定准, 所以 <code>FKDownloader</code> 直接使用 <code>stdatomic.h</code> 中的 <code>atomic_ullong</code> 来创建一个不受线程影响的原子数, 再让它被获取时自增.</p><p><code>FKCacheRequestModel</code> 的 <code>requestSingleID</code> 就是原子数和下载链接的哈希值拼接出来的.</p><p>当然, 从业务上来讲, 任务的执行顺序是否按照列表所示顺序依次进行好像并不怎么重要.</p><h5 id="FKFileManager"><a href="#FKFileManager" class="headerlink" title="FKFileManager"></a>FKFileManager</h5><p>文件管理的封装, 主要负责创建/删除任务对应的文件/文件夹.</p><h5 id="FKLogger"><a href="#FKLogger" class="headerlink" title="FKLogger"></a>FKLogger</h5><p>辅助信息日志, 这倒是没啥好说的, 只是为了更方便调试, 信息只会在 DEBUG 环境下执行.</p><h5 id="FKCoder"><a href="#FKCoder" class="headerlink" title="FKCoder"></a>FKCoder</h5><p>URL 编解码.</p><p>先说编码, 有一个问题便是用户传入的下载链接是否已经编码过, 这个可以循环解码至和上一个结果一致时停下, 这个问题不算太大. 但 URL 可能有带有 <code>emoji</code>, <code>fragment</code> 的情况, <code>emoji</code> 可以用系统的 <code>URLQueryAllowedCharacterSet</code> 直接处理, 但 <code>fragment</code> 就会编码错误, 这时就需要分段处理.</p><p>再说解码, 这个就简单了, 直接 <code>stringByRemovingPercentEncoding</code> 走起.</p><h5 id="FKMIMEType"><a href="#FKMIMEType" class="headerlink" title="FKMIMEType."></a>FKMIMEType.</h5><p>既然是文件下载, 那基本上都有后缀吧, 直接从 URL 里获取是不现实的, 毕竟有的链接是加签的, 后缀是不存在的, 所以要用 <code>Response</code> 中的 <code>Content-Type</code> 也就是 <code>MIMEType</code> 来转为后缀名.</p><p>系统可以讲 <code>MIMEType</code> 转为后缀, 但并不全面, 所以需要将其他常用的加入转换列表中, 如果实在没有对应后缀名, 就用 <code>unknown</code> 为后缀名.</p><h3 id="关于后台下载的-Tips"><a href="#关于后台下载的-Tips" class="headerlink" title="关于后台下载的 Tips"></a>关于后台下载的 Tips</h3><p>后台下载功能中也存在一些需要知道的东西.</p><h6 id="后台任务由系统启动后的各种限制"><a href="#后台任务由系统启动后的各种限制" class="headerlink" title="后台任务由系统启动后的各种限制"></a>后台任务由系统启动后的各种限制</h6><p>先说结论, 目前没有什么好的方法去绕过. 系统的限制基本上有以下几种:</p><ol><li>限制下载速度</li><li>限制何时启动下一个任务的时间</li><li>限制任务启动数量</li><li>….</li></ol><p>总的来说, iOS 为了达到完美的运行并且不会影响系统的稳定性, 后台下载的内核做了非常多的限制, 而且为什么有这些限制, 又是怎样做到的, 官方并没有明说, 只能从<a href="https://forums.developer.apple.com/thread/14854" target="_blank" rel="noopener">这里</a>看出一个重点信息, NSURLSession Background Download 是系统包揽的, 开发者最好不要深入研究.</p><h6 id="测试后台下载流程"><a href="#测试后台下载流程" class="headerlink" title="测试后台下载流程"></a>测试后台下载流程</h6><p>从<a href="https://forums.developer.apple.com/thread/14855" target="_blank" rel="noopener">这里</a>可以看出, 测试时一定要严格遵守以下几点:</p><ol><li>Test on a real device, not the simulator. 在真机上测试, 而不是模拟器.</li><li>Run your app from the Home screen rather than running it from Xcode. 从主屏幕上运行, 而不是 Xcode 直接运行.</li><li>Do not use force quit to test the ‘relaunch in the background case’. 不要从任务管理中强制退出 App 来模拟后台下载流程中的强制中断 App 逻辑, 而是在合适的地方使用 exit() 来退出 App.</li></ol><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li><a href="https://www.iana.org/assignments/media-types/media-types.xhtml" target="_blank" rel="noopener">MIMEType IANA</a></li><li><a href="https://www.freeformatter.com/mime-types-list.html#mime-types-list" target="_blank" rel="noopener">MIMEType to Extension</a></li><li><a href="https://forums.developer.apple.com/thread/14854" target="_blank" rel="noopener">NSURLSession’s Resume Rate Limiter</a></li><li><a href="https://forums.developer.apple.com/thread/14855" target="_blank" rel="noopener">Testing Background Session Code</a></li></ol></div><footer class="post-footer"><div class="post-tags"><a href="/tags/iOS/" rel="tag"># iOS</a> <a href="/tags/%E5%90%8E%E5%8F%B0%E4%B8%8B%E8%BD%BD/" rel="tag"># 后台下载</a> <a href="/tags/FKDownloader/" rel="tag"># FKDownloader</a> <a href="/tags/NSURLSession/" rel="tag"># NSURLSession</a> <a href="/tags/NSURLDownloadTask/" rel="tag"># NSURLDownloadTask</a> <a href="/tags/%E9%87%8D%E6%9E%84/" rel="tag"># 重构</a></div><div class="post-nav"><div class="post-nav-item"><a href="/2019/05/22/Masonry%E5%B0%8F%E6%8A%80%E5%B7%A7/" rel="prev" title="iOS 开发小技巧 ---- Masonry 中使用 Margin"><i class="fa fa-chevron-left"></i> iOS 开发小技巧 ---- Masonry 中使用 Margin</a></div><div class="post-nav-item"><a href="/2020/07/06/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E5%81%9A%E4%B8%80%E4%B8%AA%E5%B0%8F%E8%AF%B4%E9%98%85%E8%AF%BB%E5%8A%9F%E8%83%BD/" rel="next" title="如何优雅的做一个小说阅读功能">如何优雅的做一个小说阅读功能 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">Table of Contents</li><li class="sidebar-nav-overview">Overview</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#灵感"><span class="nav-number">2.</span> <span class="nav-text">灵感</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#后台下载框架主要难点与关键点"><span class="nav-number">3.</span> <span class="nav-text">后台下载框架主要难点与关键点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#框架模块"><span class="nav-number">4.</span> <span class="nav-text">框架模块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#框架模块详细讲解"><span class="nav-number">5.</span> <span class="nav-text">框架模块详细讲解</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#FKBuilder"><span class="nav-number">5.0.1.</span> <span class="nav-text">FKBuilder</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#FKMessager"><span class="nav-number">5.0.2.</span> <span class="nav-text">FKMessager</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#FKConfigure"><span class="nav-number">5.0.3.</span> <span class="nav-text">FKConfigure</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#FKControl"><span class="nav-number">5.0.4.</span> <span class="nav-text">FKControl</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#FKMiddleware"><span class="nav-number">5.0.5.</span> <span class="nav-text">FKMiddleware</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#FKEngine"><span class="nav-number">5.0.6.</span> <span class="nav-text">FKEngine</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#FKCache"><span class="nav-number">5.0.7.</span> <span class="nav-text">FKCache</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#FKObserver"><span class="nav-number">5.0.8.</span> <span class="nav-text">FKObserver</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#FKScheduler"><span class="nav-number">5.0.9.</span> <span class="nav-text">FKScheduler</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#FKSessionDelegater"><span class="nav-number">5.0.10.</span> <span class="nav-text">FKSessionDelegater</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#FKSingleNumber"><span class="nav-number">5.0.11.</span> <span class="nav-text">FKSingleNumber</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#FKFileManager"><span class="nav-number">5.0.12.</span> <span class="nav-text">FKFileManager</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#FKLogger"><span class="nav-number">5.0.13.</span> <span class="nav-text">FKLogger</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#FKCoder"><span class="nav-number">5.0.14.</span> <span class="nav-text">FKCoder</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#FKMIMEType"><span class="nav-number">5.0.15.</span> <span class="nav-text">FKMIMEType.</span></a></li></ol></li></ol><li class="nav-item nav-level-3"><a class="nav-link" href="#关于后台下载的-Tips"><span class="nav-number">6.</span> <span class="nav-text">关于后台下载的 Tips</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#后台任务由系统启动后的各种限制"><span class="nav-number">6.0.0.1.</span> <span class="nav-text">后台任务由系统启动后的各种限制</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#测试后台下载流程"><span class="nav-number">6.0.0.2.</span> <span class="nav-text">测试后台下载流程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#参考"><span class="nav-number">7.</span> <span class="nav-text">参考</span></a></li></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Norld" src="https://norldblog.oss-cn-shanghai.aliyuncs.com/avatar.jpg"><p class="site-author-name" itemprop="name">Norld</p><div class="site-description" itemprop="description">众所周知, 这隐藏着真理<br>显而易见, 这值得去探索</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">10</span> <span class="site-state-item-name">posts</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">1</span> <span class="site-state-item-name">categories</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">41</span> <span class="site-state-item-name">tags</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/SYFH" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;SYFH" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:norld@norld.com" title="E-Mail → mailto:norld@norld.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a></span></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2020</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Norld</span></div><div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a></div><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="Total Visitors"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-divider">|</span> <span class="post-meta-item" id="busuanzi_container_site_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="Total Views"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script src="/lib/anime.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script></body></html>